#!/bin/bash
####
## SMiLeaf Package Manager
## Author Stephen Leaf <smileaf@me.com>
## Date started: 2022/06/17

####
## Comment descriptions & formatting
## Blocks of comments or sections of code will be split up with a ####
## Comments will start with ##
## Code meant to be ignored will start with #
## Tab is set to 4 spaces

## Versions will be concurrent, but this will get updated whenever a large amount of functionality gets added or fixed.
VERSION="20230422"

## Set some bash options
## +h - Disable hashing of commands, allows newer versions of programs to be located immediately used primarily for bootstrap
##    * Should move this to the bootstrap code?
## -E - Trap ERR codes
## -e - Exit immediately on Error
set +h -Ee

## Remove write bit from group/other
umask 022

####
## Trap Errors - Only exit out if we recieve an error code 77.
##               Such as using the function die
trap '[ "$?" == 77 ] && exit 77' ERR

## Probably won't ever need this.
#trap '[ "$?" -ne 0 ] && exit $?' EXIT

## Trap SIGINT so we can properly clean-up and display information.
trap "echo -ne '\nSIGINT caught, '; cleanup; exit 1" SIGINT

####
## Ensure our config file exists
if [ -e /etc/spkg.conf ]; then
	source /etc/spkg.conf
else
	echo " * no system config file located! We'll use defaults, but a /etc/spkg.conf file should be created!"
fi

## Clean-up all Temp files.
cleanup() {
	PKG_ONLY=$1
	echo -n "Cleaning up..."

	## For security purposes, validate our BUILD_PATH
	if [[ ! -z $BUILD_PATH ]]; then
		BP=$(readlink -f $BUILD_PATH)
		if [[ ! -z $BP && $BP != '/' && -e $BUILD_PATH ]]; then
			echo -n " $BUILD_PATH .."
			rm -rf "$BUILD_PATH"
		fi
	fi
	echo " Done"

	if [ -e $INFORMLOG ]; then
		cat "$INFORMLOG"
		[[ ! -z $PKG_ONLY ]] && rm "$INFORMLOG"
	fi

	# TODO: automerge if files were not changed.
	if [[ $CONFIG_PROTECTED == 'true' ]]; then
		echo " * System configuration files were protected!"
		find /etc/ -iname "*.cfg[0-9]*"
	fi
}

## Function to figure out where this script is at so we can reference our libs directory.
## Taken from:
## https://stackoverflow.com/questions/59895/how-do-i-get-the-directory-where-a-bash-script-is-located-from-within-the-script
whereAmI() {
	SOURCE=${BASH_SOURCE[0]}
	while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
		SOURCE=$(readlink "$SOURCE")
		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
	done
	DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
	echo $DIR
}

####
## Set Environmental Variables
## Sanitize our paths in case our environment may not be complete.
export PKG_CONFIG_PATH=/lib/pkgconfig:/lib64/pkgconfig:/usr/lib/pkgconfig:/usr/lib64/pkgconfig
export LD_LIBRARY_PATH=/lib:/lib64:/usr/lib:/usr/lib64
export PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin

####
## Set some defaults if they don't exist.
MAKEOPTS=${MAKEOPTS:-"-j"$(( $(grep "cpu cores" /proc/cpuinfo|tail -n1|sed 's,.*:,,') + 1))}
CFLAGS=${CFLAGS:-"-march=native -O2 -pipe"}
CXXFLAGS=${CXXFLAGS:-"${CFLAGS}"}
ARCH=${ARCH:-x86_64}
USE=${USE:-}
PAGE=${PAGE:-letter}
ENABLE_TEST=${ENABLE_TESTS:-0}
INSTALL_DOCS=${INSTALL_DOCS:-0}
BUILD_PACKAGE=${BUILD_PACKAGE:-no}
SILENT_BUILD=${SILENT_BUILD:-no}
BUILD_USER=${BUILD_USER:-$(whoami)}
TEST_USER=${TEST_USER:-$(whoami)}
## Paths
ROOT=${ROOT:-/}
PKG_DB_DIR=${PKG_DB_DIR:-/var/db/spkg}
INSTALL_PATH=${INSTALL_PATH:-$(whereAmI)}
LOGDIR=${LOGDIR:-/var/log/spkg}
LOGFILE=${LOGFILE:-pkg-$(date +%Y%m%d).log}
INFORMLOG=/tmp/inform.log
WORKDIR_BASE=${WORKDIR_BASE:-/var/tmp/spkg}
CACHE_DIR=${CACHE_DIR:-/var/lib/spkg}
PKG_CACHE=${PKG_CACHE:-${CACHE_DIR}/data}
DISTFILES=${DISTFILES:-${CACHE_DIR}/files}
PKG_WORLD=${PKG_WORLD:-${CACHE_DIR}/world}
PKG_ARCHIVE_DIR=${PKG_ARCHIVE_DIR:-${CACHE_DIR}/archive}

export PKG_DB_DIR PKG_CACHE DISTFILES WORKDIR_BASE ROOT MAKEOPTS
export CFLAGS CXXFLAGS PAGE USE ARCHS
export ENABLE_TESTS INSTALL_DOCS BUILD_USER SILENT_BUILD

####
## Set initial program defaults
## 0 = false; 1 = true
MODE="install"
FORCE=0
PRETEND=0
ARCHIVE_INSTALL=0
VERBOSE=0

## For security reasons this shouldn't ever be used... But exists
IGNORE_SHA1=0

####
## Include our libraries
source "${INSTALL_PATH}/libs/pkg-tools"
source "${INSTALL_PATH}/libs/pkg-utils"
source "${INSTALL_PATH}/libs/builddefaults"
source "${INSTALL_PATH}/libs/spkg-include"
source "${INSTALL_PATH}/libs/utils"
source "${INSTALL_PATH}/libs/build-tools"
source "${INSTALL_PATH}/libs/list-tools"

####
## Parse our command line
parse_cmdline() {
	opts=($@)
	for (( a=0; a<$#; a++ )); do
		opt=${opts[$a]}
		val=${opts[$a+1]}
		if [[ $opt == -* ]] ; then
			opt=${opt#-}
			for i in $(seq 1 ${#opt}); do
				if [[ $opt == -* ]]; then
					o=$opt
				else
					o=${opt:$i-1:1}
				fi
				case "$o" in
					v|-verbose)
						VERBOSE=$(( $VERBOSE + 1 )) ;;
					-bootstrap)
						MODE="bootstrap"
						list="@bootstrap"
						a=$(($a + 1 ))
						ROOT=$(readlink -f $val) ;;
					-debug)
						set -x
						export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }' ;;
					-ignoresha)
						IGNORE_SHA1=1 ;;
					l|-logdir)
						a=$(( $a + 1 ))
						LOGDIR=$val ;;
					u|-uninstall)
						MODE="uninstall" ;;
					s|-search)
						MODE="search" ;;
					U|-update)
						MODE="update" ;;
					D|-deepClean)
						MODE="clean" ;;
					-sync)
						MODE="sync" ;;
					f|-force)
						FORCE=1 ;;
					-fetchOnly)
						FETCH_ONLY=1
						FORCE=1 ;;
					p|-pretend)
						PRETEND=1 ;;
					A|-installArchive)
						ARCHIVE_INSTALL="1" ;;
					-archiveDir)
						a=$(( $a + 1 ))
						PKG_ARCHIVE_DIR=$val ;;
					-enable-tests)
						ENABLE_TESTS=1 ;;
					-disable-tests)
						ENABLE_TESTS=0 ;;
					-buildbdeps)
						MODE="buildbdeps" ;;
					-updatesha1)
						HASH_UPDATE=true ;;
					-rebuildKernelMods)
						list+=" @kernelModules"
						FORCE=1
						MODE="rebuildKernelModules" ;;
					-rebuildPythonMods)
						list+=" @pythonModules"
						FORCE=1
						MODE="rebuildPythonModules" ;;
					-rebuildPerlMods)
						list+=" @perlModules"
						FORCE=1
						MODE="rebuildPerlModules" ;;
					-buildKernel)
						MODE="buildKernel" ;;
					-user)
						a=$(( $a + 1 ))
						BUILD_USER=$val ;;
					-testUsr)
						a=$(( $a + 1 ))
						TEST_USER=$val ;;
					-verify)
						VERIFY_SIG=1 ;;
					1|-oneshot)
						OMIT_RECORD_IN_WORLD=1 ;;
					Q|-silentBuild)
						SILENT_BUILD=yes ;;
					e|-empty)
						EMPTY_WORLD=1 ;;
					-preserved)
						MODE="preserved" ;;
					-version)
						echo "spkg by Stephen Leaf version $VERSION"
						exit $? ;;
					h|-help)
						echo "spkg by Stephen Leaf version $VERSION"
						echo "Usage: $0 [Arguments] [package | @set]"
						echo " @set can be any of: @all @system @world"
						echo "  see spkg-sets, for a complete listing."
						echo " Modes (Default: Install)"
						echo    "  --search, -s         Search and list package information."
						echo    "  --uninstall, -u      uninstall package."
						echo    "  --rebuildKernelMods  Rebuilds all Kernel Modules."
						echo    "  --rebuildPythonMods  Rebuilds all Python Modules."
						echo    "  --rebuildPerlMods    Rebuilds all Perl Modules."
						echo    "  --buildKernel        Builds a new kernel"
						echo    "  --deepClean, -D      Compares the charts of the world file and packages installed."
						echo    "  --sync               Syncs the package database via: git pull"
						echo    "  --preserved          Checks for and initiates a rebuild of all packages requiring a rebuild."
						echo    " Developer Options"
						echo    "  --buildbdeps         Updates .build files setting DEPS/BDEPS/RDEPS."
						echo    "  --updatesha1 [pkg]   Creates or updates sha1sum for the given package."
						echo    "  --bootstrap [path]   Generates a new install at [path]"
						echo    "  --debug              Shows all commands as they are being ran"
						echo    " Optional Arguments"
						echo    "  --silentBuild, -Q    Hides all build output."
						echo    "  --user [username]    Runs all build file commands as [username]"
						echo    "  --testUsr [username] Runs all build file test commands as [username]"
						echo    "  --oneshot, -1        Omits adding any package requested to the world file."
						echo    "  --empty, -e          Assumes an empty world file"
						echo    "  --update, -U         Finds all updates for all installed packages."
						echo    "  --force, -f          Forces install of already installed packages."
						echo    "  --pretend, -p        Shows what will be done, without doing it."
						echo    "  --fetchOnly          Fetches all files without installing."
						echo    "  --verify             Verify PGP Signatures if available."
						echo    "  --installArchive, -A Installs package(s) from a preprepared archive."
						echo    "  --archiveDir [dir]   Sets the archive Directory (default: $PKG_ARCHIVE_DIR)"
						echo -n "  --enable-tests       Enable package specific tests."
						[ $ENABLE_TESTS == 1 ] && echo " (Default)" || echo
						echo -n "  --disable-tests      Disables package specific tests."
						[ $ENABLE_TESTS == 0 ] && echo " (Default)" || echo
						echo    "  --logdir, -l [file]  Set the Log Directory (default: $LOGDIR)"
						echo    "  --verbose, -v        Make the output more verbose. (add another for extra)"
						echo    "  --help, -h           This Help Message."
						exit $? ;;
					*)
						die "Unknown option: $1 ! see --help" ;;
				esac
				if [[ $opt == -* ]]; then
					break
				fi
			done
		else
			shift $a
			list=${list:-$@}
			break
		fi
	done
}

## This function takes a list supplied on the command line and populates it with fully qualified entries (LENTRY)
## in the form:  =category/package_name-version:slot
populate_list() {
	tlist=
	list=$(expandSets $list)
	for p in $list; do
		setupENV $p
		## If a PKG_NAME is not set the package was not found, run a search so the user can fix the issue.
		if [[ $PKG_NAME == "" ]]; then
			if [[ $MODE == 'uninstall' ]]; then
				echo " !! $p not installed!"
				exit
			else
				echo " !! $p not found!"
				list=$p
				MODE=search
				return
			fi
		fi
		tlist+=" $LENTRY"
	done
	## Save a list of what was requested on the commandline.
	export REQUESTED_LIST=${tlist# }
	list=${tlist# }
}

parse_cmdline $@

####
## Ensure we can write to required directories
if [[ $MODE != 'search' ]]; then
	if [ ! -d $PKG_ARCHIVE_DIR ];
		then mkdir -p "$PKG_ARCHIVE_DIR" || die "Failed to create: PKG_ARCHIVE_DIR: $PKG_ARCHIVE_DIR"; fi
	test -w $PKG_ARCHIVE_DIR || die "Cannot write to PKG_ARCHIVE_DIR: $PKG_ARCHIVE_DIR"

	if [ ! -d $PKG_CACHE ];
		then mkdir -p "$PKG_CACHE" || die "Failed to create: PKG_CACHE: $PKG_CACHE"; fi
	test -w $PKG_CACHE || die "Cannot write to PKG_CACHE: $PKG_CACHE"
	if [[ $(stat -c '%U' "$PKG_CACHE") != $BUILD_USER ]]; then
		echo -n " * Fixing Permissions in $PKG_CACHE "
		chown -R $BUILD_USER $PKG_CACHE && echo -n '.'
		find $PKG_CACHE -type d -exec chmod 770 {} \; && echo -n '.'
		find $PKG_CACHE -type f -exec chmod 660 {} \; && echo -n '.'
		echo " done"
	fi

	if [ ! -d $DISTFILES ];
		then mkdir -p "$DISTFILES" || die "Failed to create: DISTFILES: $DISTFILES"; fi
	test -w $DISTFILES || die "Cannot write to DISTFILES: $DISTFILES"

	if [ ! -d $LOGDIR ];
		then mkdir -p "$LOGDIR" || die "Failed to create: LOGDIR: $LOGDIR"; fi
	test -w $LOGDIR || die "Cannot write to LOGDIR: $LOGDIR"

	if [ ! -d $WORKDIR_BASE ];
		then mkdir -p "$WORKDIR_BASE" || die "Failed to create: WORKDIR_BASE: $WORKDIR_BASE"; fi
	test -w $WORKDIR_BASE || die "Cannot write to WORKDIR_BASE: $WORKDIR_BASE"

	if [ ! -d $PKG_DB_DIR ]
		then mkdir -p "$PKG_DB_DIR" || die "Failed to create: PKG_DB_DIR: $PKG_DB_DIR"; fi
	test -w $PKG_DB_DIR || die "Cannot write to PKG_DB_DIR: $PKG_DB_DIR"

	[[ -e $INFORMLOG ]] && rm $INFORMLOG
	touch $INFORMLOG
	chmod 1777 $INFORMLOG

	## Populate our list with fully qualified entries so long as we're not searching.
	## We wouldn't want to destroy our search terms.
	populate_list
fi

## Calculate Binary Dependencies and update the DEPS var within the build file.
if [[ $MODE == "buildbdeps" ]]; then
	for p in $list; do
		## our list is populated with LENTRY However as they contain a version,
		## It conflicts with our ability to find the correct installed version.
		## Strip off the version (Which maybe the most recent, wrong, version as a result)
		## And preserve the slot.
		p=${p#=}  ## Remove =
		## Grab the slot if it exists
		[[ $p == *:* ]] && slot=${p##*:} || slot=0
		## Remove the Version
		p=${p%-*}
		## Append the slot if it exists
		[[ $slot != 0 ]] && p+=":$slot"
		echo "Finding Binary Dependencies: $p"
		buildBDeps $p
	done
fi

## Update the sha1sum of all files for the given package.
## Using the set @all while useful is not recommended given the size of the repository.
if [[ $HASH_UPDATE ]]; then
	C=$(echo $list | tr ' ' '\n' | wc -l)
	echo " * Updating sha1 of $C packages"
	source "${INSTALL_PATH}/libs/updatesha1"
	for p in $list; do
		PKG=$(DB-getPkg $p)
		if [[ $PKG == "" ]]; then
			echo -n "!"
			continue
		else
			updatesha1 $(getCategory $PKG)/$(getName $PKG) && echo -n "."
		fi
	done
	echo
	exit 0
fi

####
## Sync our database to the repository.
## In the future we may want to seperate our database from the package manager
## Also can support such syncing methods as rsync.
if [[ $MODE == "sync" ]]; then
	# If git is not installed, inform the user to install it.
	if [[ ! -e /usr/bin/git ]]; then
		echo " !! Git is not installed!"
		echo "    Please install it via: spkg git; Or download a copy from: https://github.com/smileaf419/spkg"
		exit 1
	fi
	cd $PKG_DB_DIR
	git pull || die " !! Sync Failed!"
fi

####
## Check for updates against whats installed and build our list.
## Take everything installed and find upgrades for it, respecting explicitly installed slots within world.
if [[ $MODE == "update" ]]; then
	echo " * Checking for updates"

	list=$(find $PKG_CACHE -mindepth 2 -maxdepth 2 -type d | sed "s,$PKG_CACHE/,," | tr '\n' ' ')
	tlist=
	for p in $list; do
		rl=$(grep $p $PKG_WORLD || true)
		if [[ $rl != '' ]]; then
			tlist+=" $rl"
		else
			tlist+=" $p"
		fi
	done
	list=$tlist
	for p in $list; do
		setupENV $p
		if [[ $(version_gt $PKG_VR $O_VER) == 0 ]]; then
			list+=" $LENTRY"
			echo $PKG_NAME :: $PKG_VR
		elif [[ $VERBOSE -gt 1 ]]; then
			echo "$PKG_CAT/$PKG_NAME not within REQUESTED_LIST or not FORCE ($REQUESTED_LIST)"
		fi
	done
	[ $VERBOSE -ge 1 ] && echo list: $list

## Build the installed kernel, will automatically rebuild all kernel modules afterwards.
elif [[ $MODE == "buildKernel" ]]; then
	buildKernel
	list="@kernelModules"
	FORCE=1
	populate_list

## Attempts to clean a system of all unessential packages.
## This is done by building 2 lists:
##  First we calculate a full list based on our @system and @world sets
##  Aftwards we gather a list of installed packages
## Finally compare the 2 lists and filter out the uniq entries.
## The entries which only exist in 1 list, will be removed.
##  In theory These entries exist installed, but not in the full list of required packages.
##  Its possible however that it got installed, then a package is updated and the uniq entry is a new package.
## FIXME: We should itterate over the list to ensure the uniq pkgs are installed, 
##        if not, error out and tell the user to run: spkg @system @world
elif [[ $MODE == "clean" ]]; then
#	ENABLE_TESTS=1
	echo " * Deep Cleaning"
	echo " * Gathering a list of @system and @world"
	list=$(expandSets "@system @world")
	echo " * Calculating Package List"
	getFullPkgList $list
	mv /tmp/chart /tmp/sysworldset
	echo " * Getting a list of installed packages."
	find $PKG_CACHE -name \*.build | fileToList | listToLEntry > /tmp/installedPkgs
	getFullPkgList $(cat /tmp/installedPkgs)
	echo " * Gathering a list of targets to remove"
	list=$(cat /tmp/chart /tmp/sysworldset | sort | uniq -u)
	REQUESTED_LIST=$list
	MODE="uninstall"
	
	# { output=$(command 2>&1 1>&3-) ;} 3>&1

## Bootstrap a new system to the given directory.
elif [[ $MODE == "bootstrap" ]]; then
	source "${INSTALL_PATH}/libs/bootstrap"
fi

## Search
if [[ $MODE == "search" ]]; then
	for p in $list; do
		## User supplied a category but the package either wasn't found or they actually did want to search for just that one...
		## use REQUESTED_LIST instead?
		## Do a search on the package name without the category.
		[[ $p == */* ]] && p=${p#*/}
		[[ $p == *:* ]] && slot=${p#*:} && p=${p%:*} || slot=
		echo "Searching: $p"
		for r in $(find $PKG_DB_DIR -maxdepth 2 -iname \*$p\* | sed "s,$PKG_DB_DIR\(/*\)\?,,"); do
			if [[ -z $slot ]]; then
				setupENV $r
			else
				setupENV $r:$slot
			fi
			if [[ $PKG_NAME != "" ]]; then
				checkSha1 ${PKG_BLD%/*} $PKG_BLD || die
				echo " * ${PKG_CAT}/${PKG_NAME}"
				echo -n "      Available:"
				for a in $(DB-getPkg $r); do
					echo -n " $(getVerRev $a)"
				done; echo

				## Run this in a subshell to avoid tainting the environment.
				echo -n "      Installed:"
				(
					for i in $(Installed-getPkg $r); do
						if [[ $i != '0//' ]]; then
							echo -n " $(getVerRev $i)"
							slot=$(getSlot $i)
							[[ $slot != 0 ]] && echo -n ":$slot"
						else
							echo -n ' none'
						fi
					done; echo
				)

				## Ditto, avoid tainting the environment
				(
					source "${PKG_BLD}"
					echo "       Homepage: ${HOMEPAGE}"
					echo "    Description: ${DESCRIPTION}"
					[[ -z $LICENSE ]] && LICENSE="Unknown"
					echo "        License: ${LICENSE}"
					[[ ! -z $IUSE ]] && echo "    USE: ${IUSE}"
					echo -n "   Dependencies: ${DEPS}"
					[[ ! -z "$UDEPS" ]] && echo -n " [U:${UDEPS}]"
					[[ ! -z "$RDEPS" ]] && echo -n " [R:${RDEPS}]"
					[[ ! -z "$BDEPS" ]] && echo -n " [B:${BDEPS}]"
					[[ ! -z "$CDEPS" ]] && echo -n " [C:${CDEPS}]"
					echo
				)
				echo
			else
				echo " !! $p not found"
				break
			fi
		done
	done
	exit 0
elif [[ $MODE == "preserved" ]]; then
	preservedRebuild
else
	## Get Dependencies and check if any require updates.
	echo " * Calculating Package Order..."
	getFullPkgList $list
	if [[ $VERBOSE -ge 1 ]]; then
		echo "Package Order (Full List):"
		cat /tmp/chart
		echo "Package Order:"
	fi
	list=
	[[ $MODE == "uninstall" ]] && tac /tmp/chart > /tmp/chart2 && mv /tmp/chart{2,}
	for p in $(cat /tmp/chart); do
		setupENV $p

		if [[ $MODE != "uninstall" ]]; then
			## By default we don't install already installed packages, even when requested
			## check forced or empty world.
			if [[ $(version_gt $PKG_VR $O_VER) == 0 ||
				($FORCE == 1 && $REQUESTED_LIST =~ (^|[[:space:]]|=)"$PKG_CAT/$PKG_NAME"(-|:|$|[[:space:]])) ||
				! -z $EMPTY_WORLD ]]; then
				echo -n "$PKG_CAT/$PKG_NAME - $PKG_VR [ $O_VER ]"
				## Only mention it's been forced if its within the REQUESTED_LIST & FORCE
				[[ $FORCE == 1 && $REQUESTED_LIST =~ (^|[[:space:]])"$PKG_CAT/$PKG_NAME"(-|:|$|[[:space:]]) ]] && echo -n " (forced)"
				[[ ! -z $IUSE ]] && echo -n " [ $IUSE ]"
				echo
				list+=" $LENTRY"
			elif [[ $VERBOSE -gt 1 ]]; then
				echo "$PKG_CAT/$PKG_NAME not within REQUESTED_LIST or not FORCE ($REQUESTED_LIST)"
			fi
		else
			if [[ $(Installed-getPkg $PKG_CAT/$PKG_NAME:$PKG_SLOT | getVersion) != 0 &&
				($REQUESTED_LIST =~ (^|[[:space:]])"=$PKG_CAT/$PKG_NAME"(-|:|$|[[:space:]])) ]]; then
				echo -n "$PKG_CAT/$PKG_NAME - $PKG_VR [ $O_VER ]"
				[[ $FORCE == 1 ]] && echo -n " (forced)"
				[[ ! -z $IUSE ]] && echo -n " [ $IUSE ]"
				echo
				list+=" $LENTRY"
			fi
		fi
	done

	[ $PRETEND == 1 ] && exit 0
	[[ -z $list ]] && die "Nothing to upgrade."

	## Install our list
	installList $list

	## Check for any preserved files
	preservedRebuild
fi

# Can use this to find applications/init scripts to restart following an update.
# lsof / | awk '/deleted/ && !/tmp/{print $9}' | sort -u
