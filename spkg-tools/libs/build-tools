#!/bin/bash
####
## Set variables to the most common defaults

## Set which configure tool we are using:  auto, meson, cmake, none
export configTool=auto

## Set which compile tool we are using:  make, ninja, pip
export buildTool=make

## no defaults to '.' yes to '..'
## Alternatively you can set a path.
export BUILD_SEPERATE_DIR=no

## If cross compiling, set this to an environment var
## SET_ABI='ABI=32'
## This will run ABI=32 ./configure ...
## Alternatively it maybe useful to use this to set other options which must be prepended to our configure call.
## FIXME: should we rename this to another name which better describes the possibility of this variable?
export SET_ABI=

####
## Setup the Build Environment
## Depending on the configure and compile tool selected we need to set a few variables
setBuildENV() {
	[[ -z $1 ]] && configTool=auto || configTool=$1
	[[ -z $2 ]] && buildTool=make || buildTool=$2
	case $configTool in
		auto)
			BDEPS+=" sys-devel/autoconf" ;;
		meson)
			BDEPS+=" dev-util/meson"
			BUILD_SEPERATE_DIR=yes ;;
		cmake)
			BDEPS+=" dev-util/cmake"
			BUILD_SEPERATE_DIR=no ;;
	esac
	case $buildTool in
		make)
			BDEPS+=" sys-devel/automake" ;;
		ninja)
			BDEPS+=" dev-util/ninja" ;;
		pip)
			BDEPS+=" dev-lang/python dev-python/pip"
			RESTRICT="nobin nostrip" ;;
		cmake)
			[[ $configTool != "cmake" ]] && BDEPS+=" dev-util/cmake"
			BUILD_SEPERATE_DIR=yes ;;
	esac
}
export -f setBuildENV

####
## buildPackage does the bulk amount of the work for any package.
## This functions is meant to be ran as BUILD_USER
## The call order of user-defined functions is:
## src_unpack
## src_patch
## src_prepare
## If we are in bootstrap mode, this will call bootstrap_default instead of the following:
##  src_configure
##  src_compile
##  src_test
buildPackage() {
	if [[ ! -z $SRC_URI ]]; then
		src_unpack

		## Enter our Build Dir
		if [ ! -d "${BUILD_PATH}/${B}" ]; then
			echo "Build Directory ($BUILD_PATH/$B) not found! Directory listing of BUILD_PATH:"
			ls "${BUILD_PATH}"
			die "exiting.."
		fi
		cd "${BUILD_PATH}/${B}"
	fi

	if [[ ! -z $PATCHES ]]; then
		echo " * src_patch"
		src_patch || die "Error While Patching"
	fi

	echo " * src_prepare"
	src_prepare

	## Used in install-init.d
	[[ $_PREPARE_ONLY == 1 ]] && return

	if [[ $BUILD_SEPERATE_DIR != "no" ]]; then
		local d
		[[ $BUILD_SEPERATE_DIR != yes ]] && d=$BUILD_SEPERATE_DIR || d=build
		install -d -o $BUILD_USER $d
		cd $d
	fi

	if [[ $MODE != "bootstrap" ]]; then
		echo " * src_configure"
		src_configure
		echo " * src_compile"
		src_compile
		if [ $ENABLE_TESTS == 1 ]; then
			echo " * src_test"
			src_test
		fi
	else
		echo " * Bootstrapping"
		bootstrap_default
	fi
}
export -f buildPackage

####
## installPackage Either installs via an archive, or builds the source.
## Afterwords creates an archive
## Cleans the install root of: libtool archives, documentation, unused language files
## Strips debug symbols
## installs into our ROOT
## removes old files if the package was installed
## and calls post_install
## finally cleans up
installPackage() {
	checkSha1 ${PKG_BLD%/*} $PKG_BLD || die
	(
		BUILD_SEPERATE_DIR=no
		source "${PKG_BLD}"

		install -o $BUILD_USER -d "${D}"

		## If the archive doesn't exist we can't do an ARCHIVE_INSTALL, build the package instead.
		if [[ $ARCHIVE_INSTALL == 1 && -e "${PKG_ARCHIVE_DIR}/${PKG_CAT}/${PKG_NAME}-${PKG_VR}.tar.gz" ]]; then
			cd "${D}"
			tar -xf "${PKG_ARCHIVE_DIR}/${PKG_CAT}/${PKG_NAME}-${PKG_VR}.tar.gz"

		## Build our source, setup the environment so we can pass things off to our BUILD_USER
		else
			src_fetch

			# src_verify

			[[ $FETCH_ONLY == 1 ]] && return

			## We need to downgrade SRC_URI for scripts to access it properly
			## Arrays cannot be exported.
			local IFS=$'\n'
			local SRC="${SRC_URI[*]}"
			export SRC_FILE=${SRC_URI[0]}
			unset SRC_URI
			export SRC_URI=$SRC
			unset SRC

			## Arrays cannot be exported
			local IFS=$'\n'
			local P="${PATCHES[*]}"
			unset PATCHES
			export PATCHES=$P
			unset P
			unset IFS

			## Ensure TEST is exported
			export TEST

			## Export this so packages can override the src_unpack.
			export LDFLAGS CXXFLAGS CFLAGS CPPFLAGS

			## We are not preparing
			export _PREPARE_ONLY=0

			## When we pass commands to our BUILD_USER these does not get updated
			## Set it here to avoid permission issues when packages call for
			## $HOME/.cache for example
			local saved_USER=$USER
			local saved_LOGNAME=$LOGNAME
			local saved_HOME=$HOME
			export USER=$BUILD_USER
			export LOGNAME=$BUILD_USER
			export HOME=$PKG_CACHE

			## Package may have overrode it.
			if ! cd "${BUILD_PATH}" > /dev/null 2>&1; then
				install -v -o $BUILD_USER -d "${BUILD_PATH}" && cd "${BUILD_PATH}" || die "Failed to create Build Dir."
			else
				chown $BUILD_USER "$BUILD_PATH"
			fi

			if [[ -e /bin/su || -e /usr/bin/su ]]; then
				su -p -c 'buildPackage' $BUILD_USER
			else
				buildPackage
			fi

			## Restore our environment
			export USER=$saved_USER
			export LOGNAME=$saved_LOGNAME
			export HOME=$saved_HOME

			cd "${BUILD_PATH}/${B}"
			if [[ $BUILD_SEPERATE_DIR != "no" ]]; then
				local d
				[[ $BUILD_SEPERATE_DIR != yes ]] && d=$BUILD_SEPERATE_DIR || d=build
				install -d -o $BUILD_USER $d
				cd $d
			fi

			## We upgrade our SRC_URI again as we won't need to worry about exporting it anymore
			IFS=$'\n'
			SRC_URI=($SRC_URI)

			echo " * src_install"
			src_install		|| die "Error in src_install"
			case $MODULE in
				kernel)
					echo > ${BUILD_PATH}/KERNEL_MODULE ;;
				perl)
					echo > ${BUILD_PATH}/PERL_MODULE ;;
				python)
					echo > ${BUILD_PATH}/PYTHON_MODULE ;;
			esac

			## Save our USE for use later.
			echo $USE > ${BUILD_PATH}/USE_FLAGS
		fi

		## Archive it up before we do any post modifications.
		archivePackage

		echo " * Removing Libtool Archives (.la)"
		find "${D}"/usr/lib{,exec,64,32} -name \*.la -delete -print 2> /dev/null # 2>&1

		if [[ $INSTALL_DOCS == 0 ]]; then
			echo " * Removing Docs"
			rm -r "${D}"/usr/share/doc > /dev/null 2>&1
			rmdir "${D}"/usr/{share,} > /dev/null 2>&1
		fi

		if [[ -e "${D}/usr/share/locale" ]]; then
			echo " * Cleaning locales"
			## Create an Exclude list
			export LIST=$(ls -1 "${D}/usr/share/locale")
			for l in $LANG ${LANG%.*} ${LANG%_*}; do
				LIST=$(grep -v $l <<< $LIST)
			done
			for l in $LIST; do
				rm -r "${D}/usr/share/locale/$l"
			done
		fi

		stripPackage

		## Gather Contents
		## This is sort of an awkward hack...
		## If we're bootstrapping we install binutils twice and gcc 3 times!
		## This causes recording issues. it should be safe to remove them if we're on pass2
		## Otherwise we're going to add to our CONTENTS
		cd $D
		if [[ $MODE == "bootstrap" && ! -z $PKG_FLAGS && $PKG_FLAGS != "pass2" ]]; then
			find . | sed "s,^\.,," | sort >> "${BUILD_PATH}/CONTENTS"
		else
			find . | sed "s,^\.,," | sort > "${BUILD_PATH}/CONTENTS"
		fi

		echo " * Merging into ${ROOT}"
		## Install New Files
		local IFS=$'\n'   # Internal Field Sperator
		local CONFIG_PROTECTED=false
		for file in $(cat "${BUILD_PATH}/CONTENTS"); do
			## Check for links before anything else
			## to avoid installing a directory when a link
			## was expected.
			if [ -L "${D}/${file}" ]; then
				ln -sf "$(readlink $D/$file)" "/$file" 2> /dev/null &&
					echo " >> $file -> $(readlink ${file})" ||
					echo "!>s $file -> $(readlink $file)"
			## Skip installing already installed dirs.
			## it overrides the user's permission customizations.
			## 2 schools of thought:
			##   1) Under most circumstances, dirs are not managed.
			##   2) Under most circumstances, most dirs are not modified by users.
			## Packages *can* modify dirs they manage and need
			## a certain way in post_install
			elif [[ -d "${D}/${file}" ]]; then
				if [[ ! -e "${file}" ]]; then
					sinstall "${D}/${file}" "${file}" && echo " >> $file" || echo "!>d $file"
				fi
			else
				## Check if a file is to be installed in /etc
				##  If it is, check if the file already exists and
				##  instead copy it to a backup file.
				if [[ $CFG_PROTECT == true && $file == */etc/* && -e "${file}" ]]; then
					## Check if the file is different
					## If the file hasn't change, we can safely ignore it.
					## If the file has changed however, protect it and report it at the end.
					if ! diff "$D/$file" "$file" > /dev/null 2>&1; then
						pfile="${file}.cfg$(date +%s)"
						cp -p "${D}/${file}" "${pfile}" && echo "cp> $file" || echo "!cp $file"
						CONFIG_PROTECTED=true
					else
						echo "a>> $file"
					fi
				## If the file is a library we must use install and not cp as the library maybe in use.
				elif [[ $file == */lib* ]]; then
					sinstall "${D}/${file}" "${file}" && echo " >> $file" || echo "!l> $file"
				else
					## if cp fails the file might be busy, but to cp is faster than sinstall due to
					## having to read permissions and then install
					## fallback on sinstall if it fails.
					if cp -p "${D}/${file}" "${file}" 2> /dev/null; then
						echo " >> $file"
					else
						if sinstall "${D}/${file}" "${file}"; then
							echo "i>> $file"
						else
							echo "!>c $file"
						fi
					fi
				fi
			fi
		done

		## Uninstall Old files
		uninstall $PKG_CAT/$PKG_NAME $PKG_VR $O_VER

		## Create the cache directory
		local CACHE_DIR="${PKG_CACHE}/${PKG_CAT}/${PKG_NAME}/${PKG_VR}"
		mkdir -p "$CACHE_DIR"
		## Copy over our build file so we can reference it in uninstalls
		cp "$PKG_BLD" "$CACHE_DIR/$PKG_VR.build"
		getBDeps "${BUILD_PATH}/CONTENTS"
		mv "${BUILD_PATH}/CONTENTS" "$CACHE_DIR/CONTENTS"
		if [ -e ${BUILD_PATH}/KERNEL_MODULE ]; then
			mv ${BUILD_PATH}/KERNEL_MODULE $CACHE_DIR/KERNEL_MODULE
		elif [ -e ${BUILD_PATH}/PERL_MODULE ]; then
			mv ${BUILD_PATH}/PERL_MODULE $CACHE_DIR/PERL_MODULE
		elif [ -e ${BUILD_PATH}/PYTHON_MODULE ]; then
			mv ${BUILD_PATH}/PYTHON_MODULE $CACHE_DIR/PYTHON_MODULE
		fi
		mv ${BUILD_PATH}/USE_FLAGS $CACHE_DIR/USE_FLAGS

		echo " * post_install"
		post_install || die "Error in post_install"

		if [[ $MODULE == kernel ]]; then
			local K_VER=$(readlink -f /usr/src/linux | sed -e 's,.*linux-,,' -e 's,/$,,')
			local KERNEL_VER=$(getMajorVer $K_VER).$(getMinorVer $K_VER).$(getMicroVer $K_VER)
			echo -n " * Running depmod (${KERNEL_VER}) .. "
			depmod -a $KERNEL_VER && echo "Ok" || echo "Failed"
		fi

		## Check if its a system package
		## Currently we don't use slots within the system set.
		## So the most recent slot should always be used.
		if ! grep "^$PKG_CAT/$PKG_NAME\$" $PKG_DB_DIR/spkg-sets/system > /dev/null 2>&1; then
			## If it didn't find it as a system package, check if its already in the world set.

			## Only add to world requested packages.
			grep "^$PKG_CAT/$PKG_NAME/[^/]*/[^/]*/[^/]*/$PKG_SLOT" $PKG_WORLD > /dev/null 2>&1
			if [[ $? != 0 && $PKG_LIST =~ (^|[[:space:]])$PKG_CAT/$PKG_NAME/[^/]*/[^/]*/[^/]*/$PKG_SLOT/ ]]; then
				if [[ -z $OMIT_RECORD_IN_WORLD ]]; then
					## Record whats requested, not just what we installed
					PKG=$(echo -e $REQUESTED_LIST | grep "$PKG_CAT/$PKG_NAME/[^/]*/[^/]*/[^/]*/$PKG_SLOT/")
					echo " * Registering into World."
					echo ${PKG# } >> $PKG_WORLD
				fi
			fi
		fi

		cleanup 1

		if [ -e $INSTALL_CHART ]; then
			## Trim the top package off and save our list of todos.
			tail -n $(( $(wc -l $INSTALL_CHART | sed 's, .*$,,') - 1 )) $INSTALL_CHART >> ${INSTALL_CHART}-2
			mv ${INSTALL_CHART}-2 $INSTALL_CHART
		fi

		echo " * $PKG_CAT/$PKG_NVR installed successfully!"
	) || die " ! Error installing $PKG_CAT/$PKG_NVR"
}

####
## Uninstalls a given package
## Arguments: Package (category/name) and version to remove.
##			 if 3rd argument is supplied diff versions and remove the old files.
uninstall() {
	local PKG=$1
	local PKG_VER=$2
	local O_VER=$3
	local FLIST=""
	[[ "$O_VER" == "0" ]] && return

	## Compare Slots
	## If slots differ we got the wrong version or the only other installed version is a different slot
	## Either way, we need to ignore it.
	[[ $(Installed-getPkgList $PKG | filterSlot $PKG_SLOT) != *build ]] && return

	if [[ "$O_VER" != "" ]]; then
		## Grep to add the filename before the files as a cheap trick
		## Sort it by 2nd field, add a space to induce a 2nd field for uniq
		## grep again for the installed version and remove the file path
		## leaving only the installed files that do not exist in the to-be installed version.
		grep -H / "${PKG_CACHE}/${PKG}/${O_VER}/CONTENTS" "${BUILD_PATH}/CONTENTS" | sort -t: -k2 | sed 's,:,: ,' | uniq -f1 -u | grep $PKG_CACHE | sed 's,.*: ,,' > /tmp/flist-$PKG_NAME
		## Reverse cat the filelist so files always come before their dirs.
		FLIST=$(tac /tmp/flist-$PKG_NAME)
		## Remove it now that we don't need it.
		rm -f /tmp/flist-$PKG_NAME
		echo "Uninstalling $PKG-$O_VER"
	else
		## Reverse cat the filelist so files always come before their dirs.
		FLIST=$(tac ${PKG_CACHE}/${PKG}/${PKG_VER}/CONTENTS)
		echo "Uninstalling $PKG-$PKG_VER"
	fi
	for file in $FLIST; do
		## While MODE=bootstrap refuse to remove files which could break things
		if [ -d "${file}" ]; then
			if [[ $MODE != "bootstrap" ]]; then
				rmdir "${file}" 2> /dev/null && echo " << $file"
			fi
		else
			## Check to see if its a versioned .so file
			## Links can be made around this and the real file might be
			## removed leaving dead links.
			local fd=
			[[ $file == *\.so* ]] && fd=$(checkFileDep $file)

			if [[ -z $fd ]]; then
				if [[ $MODE != "bootstrap" ]]; then
					rm "${file}" 2> /dev/null && echo " << $file" || echo " <! $file"
				fi
			else
				## If our file already exists within the PRESERVED_LOG don't add it
				if ! grep $file $PRESERVED_LOG; then
					echo " @! $file"
					echo $file >> $PRESERVED_LOG
				fi
				## Check if its a link, if so, read the link and add it to our PRESERVED_LOG if its not already added.
				if [ -L $file ]; then
					file=$(readlink -f $file)
					if ! grep $file $PRESERVED_LOG; then
						echo " @! $file"
						echo $file >> $PRESERVED_LOG
					fi
				fi
			fi
		fi
    done
	if [ "${O_VER}" != "${PKG_VER}" ]; then
		if [ ! -z $O_VER ]; then
			rm -r "${PKG_CACHE}/${PKG}/${O_VER}"
		else
			rm -r "${PKG_CACHE}/${PKG}/${PKG_VER}"
		fi
		## If the dir is empty remove it.
		rmdir "$PKG_CACHE/$PKG" 2> /dev/null
	fi
	if [ -z "$O_VER" ]; then
		if grep "^$PKG_CAT/$PKG_NAME" $PKG_DB_DIR/spkg-sets/system > /dev/null 2>&1; then
			echo "WARNING: You've removed a package within the system set!"
			echo "         This may cause undesired consequences!"
		else
			grep -Ev "^$PKG_CAT/$PKG_NAME/.*/$PKG_SLOT" $PKG_WORLD > $PKG_WORLD.old
			mv $PKG_WORLD.old $PKG_WORLD
		fi
	fi
}

## Create an archive package of our build, could be useful if we decide to distribute binary copies
## Enabled with BUILD_PACKAGE=yes
archivePackage() {
	# Package it up
	if [[ $BUILD_PACKAGE == "yes" && $ARCHIVE_INSTALL != 1 && $MODE != "bootstrap" ]]; then
		echo -n "Packaging up..."
		mkdir -p "${PKG_ARCHIVE_DIR}/${PKG_CAT}"
		tar -Jcpf "${PKG_ARCHIVE_DIR}/${PKG_CAT}/${PKG_NAME}-${PKG_VR}.tar.xz" . && echo " Done"
	fi
}

## Remove unneccessary symbols to reduce the filesize in binaries.
## Packages may disable this with RESTRICT=strip
stripPackage() {
	pkg-restricts strip && return
	cd "${D}"
	echo "Stripping..."
	for s in $( find . -iwholename "*bin/*" -or -iwholename "*/lib*" ); do
		strip --strip-unneeded "$s" 2> /dev/null && echo " -- $s"
	done
}

## Find all binary dependencies
## Packages may disable this with RESTRICT=nobin
getBDeps() {
	pkg-restricts nobin && return
	echo -n "Finding Binary Dependencies..."
	local bdeps=$(cat $1 | grep -P 'bin/|/lib(|32|x32|64)/') || local ERR=$?
	if [[ $ERR == 1 ]]; then
		echo " None Found"
		return 0
	fi
	for dep in $bdeps; do
		deps=$(readelf -d $dep 2> /dev/null | grep NEEDED | sed -e 's,.*\[\(.*\)\].*,\1,')
		for d in $deps; do
			for p in $(cat /etc/ld.so.conf); do
				[ -e $p/$d ] && echo $p/$d
			done
		done
	done | sort | uniq > "${PKG_CACHE}/$PKG_CAT/$PKG_NAME/$PKG_VR/BDEPS"
	echo " Done"
}

####
## Takes a list of PKG to (un)install
installList() {
	local list=($@)
	local length=${#list[@]}

	for (( l=0; l<${length}; l++ )); do
		## Current #
		local C=$(( ${l} + 1 ))
		## PKG entry
		local p=${list[$l]}
		setupENV $p

		## Uninstall
		if [[ $MODE == "uninstall" ]]; then
			echo "Uninstalling ${PKG_CAT}/$PKG_NAME : $O_VER ($C of $length)"
			(
				source $(getBldFile $p 1)
				local d=$(isDependedOn ${PKG_CAT}/$PKG_NAME $O_VER)

				## FIXME: If uninstalling will break packages Check Forced.
				## Option 1: Uninstall just the requested, breaking other installed packages.
				## Option 2: Uninstall all packages that would break, and any that would break if they were removed.
				## Option 3: Create a Minimal System Requirements package set and disallow any in that list from being
				##           removed under any circumstances.
				if [[ $d != *$p && $d != "" && $FORCE == 0 ]]; then
					echo "Uninstalling will break packages!"
					echo $d
				else
					## pre-uninstall code if needed/set
					uninstall_default
					## Uninstall the package
					uninstall "${PKG_CAT}/${PKG_NAME}" $O_VER ""
					## post-uninstall code if needed/set
					src_post_uninstall
				fi
			)

		## Install
		else
			####
			## Set the log file
			## Can alter this to use a LOGFILE using
			## %c category  %d day   %D date (%Y%m%d)  %s Unix Timestamp
			## %n name      %Y year  %m month          %v version with revision
			LOGFILE=${LOGFILE:-%D-%n%v%r.log}

			local log=$(echo $LOGDIR/$LOGFILE |
				sed -e "s,%c,$PKG_CAT," \
					-e "s,%n,$PKG_NAME," \
					-e "s,%v,$PKG_VR,"    \
					-e "s,%s,$(date +%s)," \
					-e "s,%d,$(date +%d)," \
					-e "s,%m,$(date +%m)," \
					-e "s,%Y,$(date +%Y)," \
					-e "s,%D,$(date +%Y%m%d),")

			## Our log may contain a directory or 2
			mkdir -p "${log%/*}"

			## If the file exists, append a unix timestamp to the end.
			[[ -e $log || -e $log.xz ]] && log="${log%.*}-$(date +%s).log"

			CFG_PROTECT=true

			export RESTRICT=

			echo " * ${PKG_CAT}/${PKG_NVR} ($C of $length)"

			## Save what time we started installing so we can output how long it took at the end.
			local timestart=$(date "+%s.%N")

			if [[ $SILENT_BUILD == "no" ]]; then
				set -o pipefail
				installPackage 2>&1 | tee $log
				[ $PIPESTATUS != 0 ] && die "Error installing package: ${PKG_NVR}"
			else
				installPackage > $log 2>&1 || die "Error installing package: ${PKG_NVR}"
			fi

			## If bc is installed output how long it took to build
			if [[ -e /usr/bin/bc ]]; then
				printf "Completed in %.3f seconds.\n" $( echo $(date "+%s.%N") - $timestart | bc ) | tee -a $log
			## Log when we started and when we finished if we can't calculate how long it took.
			else
				printf "Started at %.3f ended at %.3f.\n" $timestart $(date "+%s.%N") | tee -a $log
			fi

			## Compress our log.
			[[ ! -e "${log}.xz" ]] && xz "$log" || echo " ! Log ${log}.xz exists"
		fi
		echo -n " * Running ldconfig .."
		ldconfig && echo "done!" || die "failed!"
	done
}
