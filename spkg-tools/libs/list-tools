#!/bin/bash
####
## List Tools
## Defines a set of functions to build a list of packages.

## Set the Stack file
export STACK=$WORKDIR_BASE/stack

# 1: File
# Returns: list of files depending on a file.
checkFileDep() {
	grep -r --include BDEPS "$1\$" "${PKG_CACHE}"|sed -e "s,${PKG_CACHE}/,," -e "s,/BDEPS.*$,," || return 0
}

# 1: Category/Package 2: Version
# Returns: list of files depending on a package.
isDependedOn() {
	PKG=$1
	PKG_VER=$2
	pkg-restricts nobin && return
	FC=$(wc -l "$PKG_CACHE/$PKG/$PKG_VER/CONTENTS")
	if [[ ${FC% *} -gt 1000 ]]; then
		>&2 echo -n " * Checking for packages which depend on any installed files (${FC% *}) ..."
		LARGE_PKG=1
	fi
	C=0
	for f in $(cat "${PKG_CACHE}/${PKG}/${PKG_VER}/CONTENTS"); do
		C=$(( $C + 1 ))
		[[ $LARGE_PKG == 1 && $(echo $C % 1000 | bc) == 0 ]] && >&2 echo -n " $C .."
		## Ignore failures
		checkFileDep $f | sed -e 's,/[^/]*$,,' -e "s,$PKG,,"|sort|uniq|grep -v $PKG || true
	done
	[[ $LARGE_PKG == 1 ]] && >&2 echo " done"
}

# Populates a $CHART files
getFullPkgList() {
	# remove them if they exist to ensure an empty chart/stack
	[[ -e $CHART ]] && rm $CHART
	[[ -e $STACK ]] && rm $STACK
	touch $CHART $STACK

	local tlist=$@
	local flist=
	SP=
	for d in $tlist; do
		getdep $d || return $?
		flist+=" $LENTRY"
	done
	echo
}

# Take a list and expand all @sets found within.
expandSets() {
	local list=$@
	if [[ $list =~ (^|[[:space:]])"@" ]]; then
		>&2 echo " * Found Set .. Expanding"
		local slist=
		local tlist=
		for p in $list; do
			if [ ${p:0:1} == "@" ]; then
				if [[ ${p#@} == "world" ]]; then
					slist+=" $(grep -v -E "^#" $PKG_WORLD|tr '\n' ' ')"
				elif [[ ${p#@} == "all" ]]; then
					slist=$(find $PKG_DB_DIR/* -mindepth 1 -type d | sed "s,$PKG_DB_DIR/,," | grep -v spkg | tr '\n' ' ')
				elif [[ ${p#@} == "perlModules" ]]; then
					slist+=" $(rebuildModules perl)"
				elif [[ ${p#@} == "pythonModules" ]]; then
					slist+=" $(rebuildModules python)"
				elif [[ ${p#@} == "kernelModules" ]]; then
					slist+=" $(rebuildModules kernel)"
				elif [ -e $PKG_DB_DIR/spkg-sets/${p#@} ]; then
					slist+=" $(grep -v -E "^#" $PKG_DB_DIR/spkg-sets/${p#@}|tr '\n' ' ')"
				else
					>&2 echo " !! Unknown set: ${p#@}"
					>&2 echo " * Did you mean one of: "
					>&2 find $PKG_DB_DIR/spkg-sets/* | sed "s,$PKG_DB_DIR/spkg-sets/,,"
					>&2 echo "world"
					die "all"
				fi
			else
				tlist="$tlist $p"
			fi
		done
		list="$tlist $slist"
		if [[ $list == *@* ]]; then
			list=$(expandSets $list)
		fi
	fi
	echo $list
}

# 1: Package of deps to get.
# 2: if calling itself: the package which called it.
# Several Variables to describe how a dependency should be added and why its needed.
#  DEPS: Binary dependencies found via: readelf -d
# BDEPS: Build dependencies: Required for building, but not for running.
# RDEPS: Runtime Dependencies: Required for running, but not for building.
#        These should be added after the package.
# UDEPS: Optional Dependencies as required via USE
# CDEPS: Circular Dependencies are a special case where a package should be installed before and after
#        the package, but only if its not already installed.
getdep() {
	p=$1

	# Check if its on the stack, if not, add it. if so we'll get to it later.
	grep "$1" $STACK > /dev/null 2>&1 && return || echo $1 >> $STACK

	# If we somehow call ourselves..
	[[ $1 == $2 ]] && return 2

	# Print an interesting looking tree.
	if [[ $VERBOSE -ge 1 ]]; then
		>&2 echo "$SP$1"
		SP+=" "
	else
		>&2 echo -n .
	fi
	# Don't taint the environment.
	(
		setupENV $1

		if [ -e "$PKG_BLD" ]; then
			checkSha1 ${PKG_BLD%/*} $PKG_BLD || die "$PKG_BLD within $1"
			unset BDEPS RDEPS UDEPS CDEPS DEPS
			source "$PKG_BLD"
			PDEPS=
		else
			return 1
		fi

		# Add our required now Dependencies
		doDeps "${DEPS[*]} ${BDEPS[*]} ${UDEPS[*]}"

		# Check CDEPS
		if [[ ! -z $CDEPS ]]; then
			for p in $CDEPS; do
				pkg-has-flag "nodep" && break

				# If its already in the list, ignore it and continue.
				grep -E "^${d/+/\\+}\$" $CHART > /dev/null && continue

				# If its already installed, we don't need to install it twice.
				[[ $(Installed-getPkgList $p) != 0 ]] && continue

				getdep $p $PKG_CAT/$PKG_NAME || return $?

				# Create a Post Dependency list.
				PDEPS+=" $p"
			done
		fi

		# Add our package
		if ! grep -E "^=${PKG_CAT}.${PKG_NAME}.${PKG_VR}" $CHART > /dev/null; then
			echo $LENTRY >> $CHART
			sed "/^PKG_CAT.$PKG_NAME/d" -i $STACK
		fi
		# Add our Post Dependency list here.
		[[ ! -z $PDEPS ]] && echo $PDEPS | tr ' ' '\n' >> $CHART

		doDeps "${RDEPS[*]}"
		SP=${SP# }
	)
}

doDeps() {
	local DEPS=($1)
	[ -z $DEPS ] && return
	for d in ${DEPS[@]}; do
		pkg-has-flag "nodep" && break
		# If its already in the list, ignore it and continue.
		grep -E "^${d/+/\\+}\$" $CHART > /dev/null && continue

		# Identify Circular Dependencies here so we can break out

		getdep $d $PKG_CAT/$PKG_NAME || break
	done
}
