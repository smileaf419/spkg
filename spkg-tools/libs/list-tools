#!/bin/bash
####
## List Tools
## Defines a set of functions to build a list of packages.
## All Lists should be in / seperated lists

## Set the Stack file
export STACK=$WORKDIR_BASE/stack

## Checks if a given file is depended upon
## Returns: list of files depending on a file or 0 if none found.
checkFileDep() {
	grep -r --include BDEPS "$1\$" "${PKG_CACHE}"|sed -e "s,${PKG_CACHE}/,," -e "s,/BDEPS.*$,," || return 0
}

## Checks if a given PKG_CAT/PKG_NAME and PKG_VER is depended upon
## Returns: list of files depending on a package.
## FIXME: This only checks binary dependencies, we should also check the DEPS and RDEPS
isDependedOn() {
	local PKG=$1
	local PKG_VER=$2
	pkg-restricts nobin && return
	local FC=$(wc -l "$PKG_CACHE/$PKG/$PKG_VER/CONTENTS")
	if [[ ${FC% *} -gt 1000 ]]; then
		>&2 echo -n " * Checking for packages which depend on any installed files (${FC% *}) ..."
		local LARGE_PKG=1
	fi
	local C=0
	for f in $(cat "${PKG_CACHE}/${PKG}/${PKG_VER}/CONTENTS"); do
		C=$(( $C + 1 ))
		[[ $LARGE_PKG == 1 && $(( $C % 1000 )) == 0 ]] && >&2 echo -n " $C .."
		## Ignore failures
		checkFileDep $f | sed -e 's,/[^/]*$,,' -e "s,$PKG,,"|sort|uniq|grep -v $PKG || true
	done
	[[ $LARGE_PKG == 1 ]] && >&2 echo " done"
}

## Populates a $CHART files
getFullPkgList() {
	## remove files if they exist to ensure an empty chart/stack
	[[ -e $CHART ]] && rm $CHART
	[[ -e $INSTALL_CHART ]] && rm $INSTALL_CHART
	[[ -e $STACK ]] && rm $STACK
	touch $CHART $STACK $INSTALL_CHART

	SP=
	local d
	for d in $@; do
		getdep $d || local ERR=$?
		if [[ $ERR == 1 ]]; then
			>&2 echo " $DIALOG_ERROR $d called self while calculating deps"
		elif [[ $ERR == 2 ]]; then
			die " $DIALOG_ERROR Package $d Not found!"
		elif [[ $ERR == 77 ]]; then
			die
		fi
		flist+=" $LENTRY"
	done
	>&2 echo
	rm $STACK
	cat $CHART
}

## Take a list and expand all @sets found within.
expandSets() {
	local REQUEST_LIST=$@
	local PKG_LIST=
	if [[ $REQUEST_LIST =~ (^|[[:space:]])"@" ]]; then
		>&2 echo " * Found Set .. Expanding"
		local p
		for p in $REQUEST_LIST; do
			if [ ${p:0:1} == "@" ]; then
				if [[ ${p#@} == "world" ]]; then
					PKG_LIST+=" $(grep -v -E "^#" $PKG_WORLD|tr '\n' ' ')"
				elif [[ ${p#@} == "all" ]]; then
					PKG_LIST=$(find $PKG_DB_DIR/* -mindepth 1 -type d | sed "s,$PKG_DB_DIR/,," | grep -v spkg | tr '\n' ' ')
					break
				elif [[ ${p#@} == "perlModules" ]]; then
					PKG_LIST+=" $(rebuildModules perl)"
				elif [[ ${p#@} == "pythonModules" ]]; then
					PKG_LIST+=" $(rebuildModules python)"
				elif [[ ${p#@} == "kernelModules" ]]; then
					PKG_LIST+=" $(rebuildModules kernel)"
				elif [ -e $PKG_DB_DIR/spkg-sets/${p#@} ]; then
					PKG_LIST+=" $(grep -v -E "^#" $PKG_DB_DIR/spkg-sets/${p#@}|tr '\n' ' ')"
				else
					>&2 echo " $DIALOG_ERROR Unknown set: ${p#@}"
					>&2 echo " * Did you mean one of: "
					>&2 echo -n $(find $PKG_DB_DIR/spkg-sets/* | sed "s,.*/,,")
					>&2 echo -n " world"
					>&2 echo " all"
					echo "ERR"
					exit 1
				fi
			else
				PKG_LIST+=" $p"
			fi
		done
		while [[ $PKG_LIST == *@* ]]; do
			PKG_LIST=$(expandSets $PKG_LIST)
		done
		echo $PKG_LIST
	else
		echo $REQUEST_LIST
	fi
}

####
## 1: Package of deps to get.
## 2: if calling itself: the package which called it.
## Several Variables to describe how a dependency should be added and why its needed.
##  DEPS: Binary dependencies found via: readelf -d
## BDEPS: Build dependencies: Required for building, but not for running.
## RDEPS: Runtime Dependencies: Required for running, but not for building.
##        These should be added after the package.
##        But may contain some also found in BDEPS and should be filtered out.
## UDEPS: Optional Dependencies as required via USE
## CDEPS: Circular Dependencies are a special case where a package should be installed before and after
##        the package, but only if its not already installed.
##
## Return Status:
## 0 - success
## 1 - file/package not found
## 2 - Called self
getdep() {
	## Don't taint the environment.
	(
		setPkgENV $1 > /dev/null
		if [[ $PKG_VER == 0 ]]; then
			PKG=$(DB-getPkg $PKG | getLatest)
			setPkgENV $PKG
		fi

		## Check if its on the stack, if not, add it. if so we'll get to it later.
		grep -E "^$PKG_CAT/$PKG_NAME/[^/]*/[^/]*/[^/]*/$PKG_SLOT" $STACK > /dev/null 2>&1 && return 0 || eval echo \"$PKG\" >> $STACK

		## If we somehow call ourselves..
		[[ $2 =~ (^|[[:space:]])$PKG_CAT/$PKG_NAME/[^/]*/[^/]*/$PKG_SLOT/ ]] && return 1

		## Print an interesting looking tree.
		if [[ $VERBOSE -ge 1 ]]; then
			>&2 echo "$SP$PKG_CAT/$PKG_NAME-$PKG_VR:$PKG_SLOT"
			SP+=" "
		else
			>&2 echo -n .
		fi

		eval PKG_BLD=$(getBldFile $(getPKG))
		if [ -e "$PKG_BLD" ]; then
			checkSha1 ${PKG_BLD%/*} $PKG_BLD || die "Sha1sum failed for $PKG_BLD within $PKG_CAT/$PKG_NAME"
			unset BDEPS RDEPS UDEPS CDEPS DEPS
			source "$PKG_BLD"
			local PDEPS=
		else
			return 2
		fi

		## Add our required now Dependencies
		doDeps "${DEPS[*]} ${BDEPS[*]} ${UDEPS[*]}"

		## Check CDEPS
		if [[ ! -z $CDEPS ]]; then
			local p
			for p in $CDEPS; do
			    local cpkg=$(EntryParser $p)
				local cp=$(getCategory $cpkg)/$(getName $cpkg)/[^/]*/[^/]*/[^/]*/$(getSlot $cpkg)
				pkg-has-flag "nodep" && break

				## If its already in the list, ignore it and continue.
				grep -E "^${cp}" $CHART > /dev/null && continue

				## If its already installed, we don't need to install it twice.
				[[ $(Installed-getPkgList $cn) != 0 ]] && continue

				if [[ ! -z $PKG_VER_RESTRICT ]]; then
					cpkg=$(DB-getPkg $cpkg)
					>&2 echo " * Pkg has PKG_VER_RESTRICT: $PKG_VER_RESTRICT"
					>&2 echo " * Result set: $cpkg"
				else
					cpkg=$(DB-getPkg $cpkg | getLatest)
				fi
				getdep $cpkg $PKG_CAT/$PKG_NAME || return $?

				## Create a Post Dependency list.
				PDEPS+=" $cpkg"
			done
		fi

		## Add our package
		if ! grep -E "^$PKG_CAT/$PKG_NAME/[^/]*/[^/]*/[^/]*/$PKG_SLOT" $CHART > /dev/null; then
			getPKG >> $CHART
			sed "/^$PKG_CAT.$PKG_NAME/d" -i $STACK
		fi

		## Add our Post Dependency list here.
		[[ ! -z $PDEPS ]] && echo $PDEPS | tr ' ' '\n' >> $CHART

		## FIXME: We need to filter out any entries contained within BDEPS
		doDeps "${RDEPS[*]}"
		SP=${SP# }
	)
}

## Process our Dependencies
doDeps() {
	local DEPS=($@)

	[ -z $DEPS ] && return 0
	local d
	for d in ${DEPS[@]}; do
		local PKG=$(EntryParser $d)
		local PKG_VER_RESTRICT=$(getVerRestrict $PKG)
		if [ ! -z $PKG_VER_RESTRICT ]; then
			local dpkg=$(DB-getPkg $PKG)
#			>&2 echo " * Pkg has PKG_VER_RESTRICT: $PKG_VER_RESTRICT"
#			>&2 echo "PKG: $PKG"
#			>&2 echo "List: $dpkg"
			## We need to itterate over the dpkg and ensure we restrict versions to only those that match.
			local IFS="|"
			local p
			local r
			local opkg=
			for r in $PKG_VER_RESTRICT; do
				unset IFS
				if [[ ${r:0:1} == ">" && ${r:1:2} == "=" ]]; then
					for p in $dpkg; do
						if version_ge $(getVersion $p) ${r#>=}; then
							opkg+="$p\n"
						fi
					done
				elif [[ "${r:0:1}" == ">" ]]; then
					for p in $dpkg; do
						if version_gt $(getVersion $p) ${r#>}; then
							opkg+="$p\n"
						fi
					done
				elif [[ "${r:0:1}" == "<" && ${r:1:2} == "=" ]]; then
					for p in $dpkg; do
						if version_le $(getVersion $p) ${r#<=}; then
							opkg+="$p\n"
						fi
					done
				elif [[ "${r:0:1}" == "<" ]]; then
					for p in $dpkg; do
						if version_lt $(getVersion $p) ${r#<}; then
							opkg+="$p\n"
						fi
					done
				elif [[ "${r:0:1}" == "=" ]]; then
					for p in $dpkg; do
						if [[ $(getVersion $p) == ${r#>} ]]; then
							opkg+="$p\n"
						fi
					done

				fi
			done
			dpkg=$(echo -e $opkg | getLatest)
		else
			local dpkg=$(DB-getPkg $PKG | getLatest)
		fi
		pkg-has-flag "nodep" && break
		## If its already in the list, ignore it and continue.
		dpkg=${dpkg:?Error resolving dependencies}
		grep -E "^$(getCategory $dpkg)/$(getName $dpkg)/[^/]*/[^/]*/[^/]*/$(getSlot $dpkg)" $CHART > /dev/null && continue

		## Identify Circular Dependencies here so we can break out
		getdep $dpkg $PKG_CAT/$PKG_NAME || local e=$?
		if [[ ! -z $e && ! $e ]]; then
			>&2 echo "Got return $e in $d"
			break
		fi
	done
}
