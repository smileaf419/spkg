#!/bin/bash
####
## Build file default methods
## The purpose of this file is to describe how packages are built.
## a function-less build file by default will call:
## src_fetch
## src_verify
## src_unpack
## src_patch
## src_prepare
## src_configure
## src_compile
## src_test
## src_install
## post_install
##
## Overriding these functions allows you to customize what is ran at each step.
## src_configure and src_compile are ran as BUILD_USER
## src_test is ran as BUILD_USER
## src_install and post_install are ran as root.
##
## All overridden functions must be self-contained as environments will be reset between each function.
## if a global variable is to be set for all functions, it should be done so at the top level, or within src_prepare.

####
## Multilib
## This is the default Other options are 32 and x32
export LIB=64

####
## Bootstrapping is done a bit backwards from how the functions are normally setup
## this is because several variables *MUST* be set before the bootstrap code is ran.
## As a result bootstrap_default is called and then bootstrap is called from within,
## rather than bootstrap being called and bootstrap_default being called from within.
## This is keeps the code a bit cleaner, while still enforcing the variables get set.
## All bootstrap code is ran as BUILD_USER, so to simplify things its also all handled
## Within the bootstrap() function.
bootstrap() {
	src_configure
	src_compile
	src_install
}
export -f bootstrap

bootstrap_default() {
	umask 022
	set +h
	export HOST_TGT=$(uname -m)-leaf-linux-gnu
	export HOST_TGT32=i686-leaf-linux-gnu
	export HOST_TGTx32=${HOST_TGT}x32
	export BOOTSTRAP_TGT=${BOOTSTRAP_TGT:-x86_64-leaf-linux-gnu}
	export BOOTSTRAP_TGT32=${BOOTSTRAP_TGT32:-i686-leaf-linux-gnu}
	export BOOTSTRAP_TGTx32=${BOOTSTRAP_TGTx32:-x86_64-leaf-linux-gnux32}
	export PATH="$ROOT/tools/bin:/bin:/sbin:/usr/bin:/usr/sbin"
	export CONFIG_SITE=$ROOT/usr/share/config.site

	# The above code *MUST* be ran
	bootstrap
}
export -f bootstrap_default

####
## *_default Functions

####
## Configure our package using the set configure tool.
## default options maybe reset with CONF_FLAGS= if the defaults conflict with desired ones.
configure_default() {
	## FIXME: Currently we default to x86_64 with no way for build files to change this.
	##        Earlier we should examine the ARCH and set it appropriately.
	##        x86 set default to HOST_TGT32
	HOST_TGT=${HOST_TGT:-x86_64-pc-linux-gnu}
	HOST_TGT32=${HOST_TGT32:-i686-pc-linux-gnu}
	HOST_TGTx32=${HOST_TGTx32:-x86_64-pc-linux-gnux32}
	local d=.
	if [[ $BUILD_SEPERATE_DIR != no ]]; then
		[[ $BUILD_SEPERATE_DIR == yes ]] && d=.. || d=$BUILD_SEPERATE_DIR
	fi
	if [[ $configTool == "auto" ]]; then
		# Not all packages support these options.
		# Allow them to override and still benefit from the use of
		# customizing the *FLAGS.
		CONF_FLAGS=${CONF_FLAGS:=--prefix=/usr --disable-static --enable-shared --docdir=/usr/share/doc/${PKG_NVR}}
		if [[ -z $LIB || $LIB == 64 ]]; then
			[[ $MODE == 'bootstrap' ]] && CONF_FLAGS+=" --host=$HOST_TGT"
			LD_LIBRARY_PATH="$LD_LIBRARY_BASE:/lib64:/usr/lib64"
			PKG_CONFIG_PATH="$PKG_CONFIG_BASE:/lib64/pkgconfig:/usr/lib64/pkgconfig"
		elif [[ $LIB == 32 ]]; then
			CONF_FLAGS+=" --host=$HOST_TGT32"
			filter-flags -march
			LD_LIBRARY_PATH="$LD_LIBRARY_BASE:/lib32:/usr/lib32"
			PKG_CONFIG_PATH="$PKG_CONFIG_BASE:/lib32/pkgconfig:/usr/lib32/pkgconfig"
		elif [[ $LIB == x32 ]]; then
			CONF_FLAGS+=" --host=$HOST_TGTx32"
			LD_LIBRARY_PATH="$LD_LIBRARY_BASE:/libx32:/usr/libx32"
			PKG_CONFIG_PATH="$PKG_CONFIG_BASE:/libx32/pkgconfig:/usr/libx32/pkgconfig"
		fi

		>&2 echo "LDFLAGS=$LDFLAGS"
		>&2 echo "CFLAGS=$CFLAGS"
		>&2 echo "CPPFLAGS=$CPPFLAGS"
		>&2 echo "CXXFLAGS=$CXXFLAGS"
		>&2 echo "LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
		>&2 echo "SET_ABI=$SET_ABI"
		>&2 echo "CONF_FLAGS=${CONF_FLAGS[@]}"
		>&2 echo "@=$@"

		eval \
		LDFLAGS=\"$LDFLAGS\"   \
		CFLAGS=\"$CFLAGS\"     \
		CPPFLAGS=\"$CPPFLAGS\" \
		CXXFLAGS=\"$CXXFLAGS\" \
		LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\" \
		$SET_ABI               \
			$d/configure ${CONF_FLAGS[@]} "$@" || die " $DIALOG_ERROR Configure Failed!"
	elif [[ $configTool == "meson" ]]; then
		CONF_FLAGS=${CONF_FLAGS:=--prefix=/usr --buildtype=release}
		meson setup ${CONF_FLAGS[@]} "$@" $d || die " $DIALOG_ERROR Configure Failed!"
	elif [[ $configTool == "cmake" ]]; then
		CONF_FLAGS=${CONF_FLAGS:=-DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_DOCDIR=/usr/share/doc/${PKG_NVR}}
		cmake ${CONF_FLAGS[@]} "$@" -B $d/build -S $d || die " $DIALOG_ERROR Configure Failed!"
	fi
}
export -f configure_default

####
## Some packages come with python bindings
## Allow just the pip commands to run without having to set a special build environment
python_compile() {
	_PIP_COMPILE_OPTS=${_PIP_COMPILE_OPTS:-"-w dist --no-build-isolation --no-deps"}

	>&2 echo " * Running pip with $_PIP_COMPILE_OPTS"
	if ! eval pip3 wheel -v $_PIP_COMPILE_OPTS $PWD; then
		echo " $IMPORTANT Assuming pip is broken. Reinstalling and trying again."
		fetch_file "https://bootstrap.pypa.io/get-pip.py" "get-pip.py"
		python $DISTFILES/get-pip.py --no-warn-script-location
		PATH+=":$HOME/.local/bin"

		eval pip3 wheel -v $_PIP_COMPILE_OPTS $PWD || die " $DIALOG_ERROR Failed to install $PKG_CAT/$PKG_NAME"
	fi
}
export -f python_compile

####
## Build our package using the set build-tool
compile_default() {
	if [[ $buildTool == "make" ]]; then
		[[ $configTool == "cmake" && $BUILD_SEPERATE_DIR == "no" ]] && cd build
		make $MAKEOPTS $@ || die " $DIALOG_ERROR Compile Failed!"
	elif [[ $buildTool == "ninja" ]]; then
		ninja || die " $DIALOG_ERROR Compile Failed!"

	## Compile the python module
	## Build options maybe overridden via _PIP_COMPILE_OPTS
	elif [[ $buildTool == "pip" ]]; then
		python_compile
	elif [[ $buildTool == "cmake" ]]; then
		local d=.
		if [[ $BUILD_SEPERATE_DIR != no ]]; then
			[[ $BUILD_SEPERATE_DIR == yes ]] && d=.. || d=$BUILD_SEPERATE_DIR
		fi
		cmake --build $d/build
	fi
	return 0
}
export -f compile_default

####
## Run the package's test suites
## defaults to a: make check
## to use `make test` use TEST=test
test_default() {
	# Some use check, others use test
	TEST=${TEST:-check}

	if [[ $buildTool == "make" ]]; then
		make $MAKEOPTS $@ $TEST || die " $DIALOG_ERROR Test Failed!"
	elif [[ $buildTool == "ninja" ]]; then
		ninja test || die " $DIALOG_ERROR Test Failed!"
	fi
}
export -f test_default

####
## Some packages come with python bindings
## Allow just the pip commands to run without having to set a special build environment
python_install() {
	## Because we run each function in a seperate, environment variables set within them do not keep
	## Assume we are installing a precompiled rather than the one we built unless SPKG_PIP_INSTALL_COMPILED is set.
	## Installed options maybe overridden via _PIP_OPTS
	[[ -z $SPKG_PIP_INSTALL_COMPILED ]] &&
		_PIP_INSTALL_OPTS=${_PIP_INSTALL_OPTS:-"--no-index --find-links dist --no-cache-dir"}

	>&2 echo " * Running pip with $_PIP_INSTALL_OPTS --upgrade --no-deps --no-user --force-reinstall --ignore-installed (prefix: $D/usr)"
	if ! eval python -m pip install -v --upgrade --prefix=$D/usr $_PIP_INSTALL_OPTS --no-deps --no-user --force-reinstall --ignore-installed $PKG_NAME; then
		echo " $IMPORTANT Assuming pip is broken. Reinstalling and trying again."
		fetch_file "https://bootstrap.pypa.io/get-pip.py" "get-pip.py"
		python $DISTFILES/get-pip.py

		eval python -m pip install -v --upgrade --prefix=$D/usr $_PIP_INSTALL_OPTS --no-deps --no-user --force-reinstall $PKG_NAME || die " $DIALOG_ERROR Failed to install $PKG_CAT/$PKG_NAME"
	fi
}
export -f python_install

####
## Install our package using the our set build-tool
install_default() {
	if [[ $buildTool == "make" ]]; then
		[[ $configTool == "cmake" && $BUILD_SEPERATE_DIR == "no" ]] && cd build
		make DESTDIR="${D}/$ROOT" $@ install || die " $DIALOG_ERROR Install Failed!"
	elif [[ $buildTool == "ninja" ]]; then
		DESTDIR="${D}/$ROOT" ninja install || die " $DIALOG_ERROR Install Failed!"
	elif [[ $buildTool == "pip" ]]; then
		python_install
	elif [[ $buildTool == "cmake" ]]; then
		local d=.
		if [[ $BUILD_SEPERATE_DIR != no ]]; then
			[[ $BUILD_SEPERATE_DIR == yes ]] && d=.. || d=$BUILD_SEPERATE_DIR
		fi
		DESTDIR="$D/$ROOT" cmake --install $d/build
	fi
}
export -f install_default

####
## Uninstall the package using our set build-tool
uninstall_default() { :; }
export -f uninstall_default

## Function called by src_fetch
fetch_default() {
	fetch_list "Fetching Files" "$(IFS=$'\n'; echo "${SRC_URI[*]}")" 'src'
	fetch_list "Fetching Patches" "$(IFS=$'\n'; echo "${PATCHES[*]}")" 'patch'
}
export -f fetch_default

####
## Function called by src_verify
## Currently disabled until a better design can be implemented for properly verifying signatures and installing keys.
verify_default() {
## Check a sig file if it exists.
## FIXME: This code fails if there is no public key installed.
## Build files should depend on a public key package.
#if [[ $VERIFY_SIG == 1 && $file == *.sig ]]; then
#	echo -n "Checking Signature: ${DISTFILES}/${SRC_FILE%.*} ..."
#	gpg --verify "${DISTFILES}/${SRC_FILE}" "${DISTFILES}/${SRC_FILE%.*}" 2>&1 | grep "Good signature" >/dev/null
#	[ $? == 0 ] && echo "Ok" || die "Failed!"
#fi
	:;
}
export -f verify_default

## Function called by src_unpack
unpack_default() {
	# We only unpack the first one, anything else will need to be done via the build file.
    unpack "${DISTFILES}/${SRC_FILE##*/}"
}
export -f unpack_default

## Function called by src_patch
patch_default() {
	spatches "$@" || die " $DIALOG_ERROR Patching failed"
}
export -f patch_default

####
## Default empty functions (src_*)

## This is useful for finishing setting up the environment before we start our build.
src_prepare() { :; }
export -f src_prepare

## Will by default call a fetch_list on SRC_URI and PATCHES
src_fetch() { fetch_default; }
export -f src_fetch

## use PGP to verify signatures
src_verify() { verify_default; }
export -f src_verify

## By Default only unpack the first entry in our SRC_URI
src_unpack() { unpack_default; }
export -f src_unpack

## call spatches on PATCHES
src_patch() {
	patch_default "${@:-${PATCHES[*]}}"
}
export -f src_patch

## Ran as BUILD_USER
src_configure() { configure_default; }
export -f src_configure

## Ran as BUILD_USER
src_compile() { compile_default; }
export -f src_compile

## Ran as BUILD_USER
src_test() { test_default; }
export -f src_test

## Ran as root
src_install() { install_default; }
export -f src_install

## Ran as root
post_install() { :; }
export -f post_install

## Ran as root before we remove files
src_uninstall() { :; }
export -f src_uninstall

## Ran as root after we have removed all files
src_post_uninstall() { :; }
export -f src_post_uninstall
