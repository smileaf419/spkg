#!/bin/bash
####
## Build file default methods
## The purpose of this file is to describe how packages are built.
## a function-less build file by default will call:
## src_fetch
## src_verify
## src_unpack
## src_patch
## src_prepare
## src_configure
## src_compile
## src_test
## src_install
## post_install
##
## Overriding these functions allows you to customize what is ran at each step.
## src_configure and src_compile are ran as BUILD_USER
## src_test is ran as TEST_USER
## src_install and post_install are ran as root.
##
## All overridden functions must be self-contained as environments will be reset between each function.
## if a global variable is to be set for all functions, it should be done so at the top level, or within src_prepare.

####
## Set variables to the most common defaults

## Set which configure tool we are using:  auto, meson, cmake, none
export configTool=auto

## Set which compile tool we are using:  make, ninja, pip
export buildTool=make

## no defaults to '.' yes to '..'
## Alternatively you can set a path.
export BUILD_SEPERATE_DIR=no

## If cross compiling, set this to an environment var
## SET_ABI='ABI=32'
## This will run ABI=32 ./configure ...
## Alternatively it maybe useful to use this to set other options which must be prepended to our configure call.
## FIXME: should we rename this to another name which better describes the possibility of this variable?
export SET_ABI=

####
## Setup the Build Environment
## Depending on the configure and compile tool selected we need to set a few variables
setBuildENV() {
	[[ -z $1 ]] && configTool=auto || configTool=$1
	[[ -z $2 ]] && buildTool=make || buildTool=$2
	case $configTool in
		auto)
			BDEPS+=" sys-devel/autoconf" ;;
		meson)
			BDEPS+=" dev-util/meson"
			BUILD_SEPERATE_DIR=yes ;;
		cmake)
			BDEPS+=" dev-util/cmake" ;;
	esac
	case $buildTool in
		make)
			BDEPS+=" sys-devel/automake" ;;
		ninja)
			BDEPS+=" dev-util/ninja" ;;
		pip)
			RESTRICT="nobin nostrip" ;;
	esac
}
export -f setBuildENV

####
## Default empty functions

## Like bootstrap prepare_default is called which then calls src_prepare
## This code is useful for finishing setting up the environment before we start our build.
src_prepare() { :; }
export -f src_prepare

## Will by default call a fetch_list on SRC_URI and PATCHES
src_fetch() { fetch_default; }
export -f src_fetch

## use PGP to verify signatures
src_verify() { verify_default; }
export -f src_verify

## By Default only unpack the first entry in our SRC_URI
src_unpack() {
	# We only unpack the first one, anything else will need to be done via the build file.
    unpack "${DISTFILES}/${SRC_FILE##*/}"
}
export -f src_unpack

## call spatches on PATCHES
src_patch() { patch_default; }
export -f src_patch

## Ran as BUILD_USER
src_configure() { configure_default; }
export -f src_configure

## Ran as BUILD_USER
src_compile() { compile_default; }
export -f src_compile

## Ran as TEST_USER
src_test() { test_default; }
export -f src_test

## Ran as root
src_install() { install_default; }
export -f src_install

## Ran as root
post_install() { :; }
export -f post_install

## Ran as root before we remove files
src_uninstall() { :; }
export -f src_uninstall

## Ran as root after we have removed all files
src_post_uninstall() { :; }
export -f src_post_uninstall

####
## Bootstrapping is done a bit backwards from how the functions are normally setup
## this is because several variables *MUST* be set before the bootstrap code is ran.
## As a result bootstrap_default is called and then bootstrap is called from within,
## rather than bootstrap being called and bootstrap_default being called from within.
## This is keeps the code a bit cleaner, while still enforcing the variables get set.
## All bootstrap code is ran as BUILD_USER, so to simplify things its also all handled
## Within the bootstrap() function.
bootstrap_default() {
	umask 022
	set +h
#	export HOST_TGT=$(uname -m)-leaf-linux-gnu
	export HOST_TGT=${HOST_TGT:-x86_64-leaf-linux-gnu}
	export HOST_TGT32=${HOST_TGT32:-i686-leaf-linux-gnu}
	export HOST_TGTX32=${HOST_TGTX32:-x86_64-leaf-linux-gnux32}
	export PATH="$ROOT/tools/bin:/bin:/sbin:/usr/bin:/usr/sbin"
	export CONFIG_SITE=$ROOT/usr/share/config.site

	# The above code *MUST* be ran
	bootstrap
}
export -f bootstrap_default
bootstrap() {
	configure_default
	compile_default
	install_default
}
export -f bootstrap

####
## Configure our package using the set configure tool.
## default options maybe reset with CONF_FLAGS= if the defaults conflict with desired ones.
configure_default() {
	# FIXME: Currently we default to x86_64 with no way for build files to change this.
	HOST_TGT=${HOST_TGT:-x86_64-pc-linux-gnu}
	HOST_TGT32=${HOST_TGT32:-i686-pc-linux-gnu}
	HOST_TGTx32=${HOST_TGTx32:-x86_64-pc-linux-gnux32}
	d=.
	if [[ $BUILD_SEPERATE_DIR != no ]]; then
		[[ $BUILD_SEPERATE_DIR == yes ]] && d=.. || d=$BUILD_SEPERATE_DIR
	fi
	if [[ $configTool == "auto" ]]; then
		# Not all packages support these options.
		# Allow them to override and still benefit from the use of
		# customizing the *FLAGS.
		CONF_FLAGS=${CONF_FLAGS:=--prefix=/usr --disable-static --enable-shared --docdir=/usr/share/doc/${PKG_NVR}}
		[[ $MODE == "bootstrap" ]] && CONF_FLAGS+=" --host=$HOST_TGT"

		LDFLAGS="$LDFLAGS"   \
		CFLAGS="$CFLAGS"     \
		CPPFLAGS="$CPPFLAGS" \
		CXXFLAGS="$CXXFLAGS" \
		$SET_ABI             \
			$d/configure ${CONF_FLAGS} "$@" || die "Configure Failed!"
	elif [[ $configTool == "meson" ]]; then
		CONF_FLAGS=${CONF_FLAGS:=--prefix=/usr --buildtype=release}
		meson setup ${CONF_FLAGS} "$@" $d || die "Configure Failed!"
	elif [[ $configTool == "cmake" ]]; then
		CONF_FLAGS=${CONF_FLAGS:=-DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_DOCDIR=/usr/share/doc/${PKG_NVR}}
		cmake ${CONF_FLAGS} "$@" $d || die "Configure Failed!"
	fi
}
export -f configure_default

####
## Build our package using the set build-tool
compile_default() {
	if [[ $buildTool == "make" ]]; then
		make $MAKEOPTS $@ || die "Compile Failed!"
	elif [[ $buildTool == "ninja" ]]; then
		ninja || die "Compile Failed!"
	fi
}
export -f compile_default

####
## Run the package's test suites
## defaults to a: make check
## to use `make test` use TEST=test
test_default() {
	# Some use check, others use test
	TEST=${TEST:-check}

	if [[ $buildTool == "make" ]]; then
		make $MAKEOPTS $@ $TEST || die "Test Failed!"
	elif [[ $buildTool == "ninja" ]]; then
		ninja test || die "Test Failed!"
	fi
}
export -f test_default

####
## Install our package using the our set build-tool
install_default() {
	if [[ $buildTool == "make" ]]; then
		make DESTDIR="${D}/$ROOT" $@ install || die "Install Failed!"
	elif [[ $buildTool == "ninja" ]]; then
		DESTDIR="${D}/$ROOT" ninja install || die "Install Failed!"
	elif [[ $buildTool == "pip" ]]; then
		# FIXME: This seems to happen too frequently.. like even once is too many times. Why?
		if ! python -m pip install --upgrade $PKG_NAME; then
			echo " !! Assuming pip is broken. Reinstalling and trying again."
			fetch_file "https://bootstrap.pypa.io/get-pip.py" "get-pip.py"
			python $DISTFILES/get-pip.py

			python -m pip install --upgrade $PKG_NAME
		fi
	fi
}
export -f install_default

####
## Uninstall the package using our set build-tool
uninstall_default() {
	if [[ $buildTool == "pip" ]]; then
		python -m pip uninstall -y $PKG_NAME
	fi
}
export -f uninstall_default
