#!/bin/bash
####
## Package Utils
## Author: Stephen Leaf <smileaf@me.com>
## Date: 2023-04-08
##
## Methods are split-up into 3 segments:
## Installed - Used to retrieve data from installed packages
## Db        - Used to retrieve current data from available packages.
##
## (this file)
## Utils     - Useful methods build files may need to perform commonly operations.
##
### Installed and Db should contain the same named methods but from different pools (PKG_DB_DIR and PKG_CACHE)

####
## Output a dialog and exit immediately.
die() { echo "$*" 1>&2 ; exit 77; }
export -f die

####
## Output a dialog and append it to a log file.
## This logfile will then be outputted again at the very end.
inform() { echo "$*" | tee -a $INFORMLOG; }
export -f inform

####
## Utility method to unpack a variety of archives.
## Optionally extract the archive to a certain directory.
## Currently supports: tar.*, .zip, .deb and .rar
unpack() {
	FILE=$1
	DIR=${2:-.}

	echo " * Unpacking $FILE to $DIR"
	if [[ $FILE == *.tar.* || $FILE == *.tgz ]]; then
		tar -xf "$FILE" -C "$DIR" || die "Failed to extract!"
	elif [ ${FILE##*.} == "zip" ]; then
		unzip -o "$FILE" -d "$DIR" || die "Failed to extract!"
	elif [ ${FILE##*.} == "deb" ]; then
		ar x --output "$DIR" "$FILE"
	elif [ ${FILE##*.} == "rar" ]; then
		[ ! -e /usr/bin/unrar ] && die " ! 'app-arch/unrar' not installed! cannot extract archive"
		unrar x "$FILE" "DIR"
	# TODO: Add rpm support
	#       https://stackoverflow.com/questions/18787375/how-do-i-extract-the-contents-of-an-rpm
	else
		die "Cannot extract unknown type: $FILE"
	fi
}
export -f unpack

####
## Applies a patch, optionally with a set of arguments.
spatch() {
	patch=$1
	shift 1
	patch_options=${@:--Np1}
	echo -n " * Applying Patch: $patch ($patch_options)"
	if [[ $patch == *gz ]]; then
		gzip -cd "$patch" | patch $patch_options > /dev/null || die " .. Failed!"
	elif [[ $patch == *xz ]]; then
		xz -cd "$patch" | patch $patch_options > /dev/null || die " .. Failed!"
	elif [[ $patch == *bz2 ]]; then
		bzip2 -cd "$patch" | patch $patch_options > /dev/null || die " .. Failed!"
	else
		patch $patch_options -i "$patch" > /dev/null || die " .. Failed!"
	fi
	echo " .. Ok!"
}
export -f spatch

####
## Applies a set of patches, within the array, a directory or an archive (tar only).
## src_patch automatically calls this method using the PATCHES var.
spatches() {
	if [ ! -z "$@" ]; then
		PATCHES=($@)
	fi
	for p in ${PATCHES[*]}; do
		[[ $p == http* ]] && p=$DISTFILES/${p##*/}
		if [[ $p == *.tar.* ]]; then
			unpack "$p"
			p=${p%.tar.*}
			p=${p##*/}
			echo " * p : $p"
		fi
		if [ -d "$p" ]; then
			echo " * Applying All patches within: $p"
			spatches "$(find "$p" -type f -iname '*.patch' | sort)"
		else
			spatch "$p"
		fi
	done
}
export -f spatches

####
## Removes flags from CFLAGS, CXXFLAGS and CPPFLAGS
filter-flags() {
	flags=$@
	for flag in $flags; do
		CFLAGS=$(echo $CFLAGS|sed "s,$flag,,")
		CXXFLAGS=$(echo $CXXFLAGS|sed "s,$flag,,")
		CPPFLAGS=$(echo $CPPFLAGS|sed "s,$flag,,")
	done
	export CFLAGS CXXFLAGS CPPFLAGS
}
export -f filter-flags

## Append flags to LDFLAGS
append-ldflags() { export LDFLAGS+=" $@"; }
export -f append-ldflags

## Append C flags
append-cflags() { export CFLAGS+=" $@"; }
export -f append-cflags

## Append C++ flags
append-cxxflags() { export CXXFLAGS+=" $@"; }
export -f append-cxxflags

## Append C Pre-processor Flags
append-cppflags() { export CPPFLAGS+=" $@"; }
export -f append-cppflags

####
## Within a version string of x.y.z
## This will return: x
getMajorVer() {
	[[ -z $1 ]] && VER=$PKG_VER || VER=$1
	echo $VER | tr '.' '\n'|head -n1
}
export -f getMajorVer

####
## Within a version string of x.y.z
## This will return: y
getMinorVer() {
	[[ -z $1 ]] && VER=$PKG_VER || VER=$1
	c=$(echo $VER | tr '.' '\n'|wc -l)
	if [[ $c == 2 ]]; then
		echo $VER | tr '.' '\n'|tail -n1
	elif [[ $c -ge 3 ]]; then
		echo $VER | tr '.' '\n'|head -n2|tail -n1
	else
		echo 0
	fi
}
export -f getMinorVer

####
## Within a version string of x.y.z
## This will return: z
getMicroVer() {
	[[ -z $1 ]] && VER=$PKG_VER || VER=$1
	n=$(echo $VER|tr '.' '\n'|wc -l)
	if [[ $n == 3 ]]; then
		echo $VER|tr '.' '\n'|tail -n1
	else
		echo 0
	fi
}
export -f getMicroVer

####
## Check the USE flag for an option,
## return 0 if found; 1 if not.
## returns 2 if found and is disabled
use-enable() { checkinlist $1 "$USE"; }
export -f use-enable

####
## Check the PKG_FLAGS for an option,
## return 0 if found; 1 if not.
## returns 2 if found and is disabled
pkg-has-flag() { checkinlist $1 "$PKG_FLAGS"; }
export -f pkg-has-flag

####
## Check the RESTRICT for an option,
## return 0 if found; 1 if not.
## returns 2 if found and is disabled
pkg-restricts() { checkinlist $1 "$RESTRICT"; }
export -f pkg-restricts

####
## Checks for a String(2) within a Variable(1)
## Returns 0 if found, 1 if not, and 2 if found and is disabled.
checkinlist() {
	local var=$1
	shift
	local list=$@
	if [[ ${V[*]} =~ (^|[[:space:]])"$var"($|[[:space:]]) ]]; then
		return 0
	fi
	if [[ ${V[*]} =~ (^|[[:space:]])-"$var"($|[[:space:]]) ]]; then
		return 2
	fi
	return 1
}
export -f checkinlist

####
## Check if a config option (1) is set to either Y/M(2)
## Display a dialog describing the config option(3)
checkKernelConfig() {
	CONFIG=$1
	NEEDS_MODULE=$2
	DIALOG=$3
	HAS_PROC=0
	HAS_CONFIG=0

	if [ $NEEDS_MODULE == 0 ]; then
		ERROR_DIALOG="$CONFIG Needs Disabled"
	else
		ERROR_DIALOG="$CONFIG Needs to be Y (built-in) or M (module)"
	fi

	echo -n "Checking for $DIALOG"
	if [ -f /proc/config.gz ]; then
		echo -n " [/proc/config.gz: "
		gzip -cd /proc/config.gz | grep -E "${CONFIG}=[ym]" > /dev/null
		[ $? != $NEEDS_MODULE ] && echo -n "Ok]" && HAS_PROC=1 || echo -n "No]"
	fi
	if [ -f /usr/src/linux/.config ]; then
		echo -n " [/usr/src/linux/.config: "
		grep -E "${CONFIG}=[ym]" /usr/src/linux/.config > /dev/null
		[ $? != $NEEDS_MODULE ] && echo -n "Ok]" && HAS_CONFIG=1 || echo -n "No]"
	fi
	[[ $HAS_PROC == 1 || $HAS_CONFIG == 1 ]] && echo || die $ERR_DIALOG
}
export -f checkKernelConfig

####
## Frontend to useradd
## If the user is found, calls usermod instead.
addUser() {
	USER=$1
	shift 1
	if ! grep "^${USER}:" /etc/passwd > /dev/null 2>&1; then
		echo " * Adding User $USER"
		useradd "$@" $USER
	else
		echo " * User Exists: Updating [$@]"
		usermod "$@" $USER
	fi
}
export -f addUser

####
## Frontend to groupadd
## If the group is found, calls groupmod instead.
addGroup() {
	GROUP=$1
	shift 1
	if ! grep "^${GROUP}:" /etc/group > /dev/null 2>&1; then
		echo " * Adding Group $GROUP"
		groupadd "$@" $GROUP
	else
		echo " * Group Exists: Updating [$@]"
		groupmod "$@" $GROUP
	fi
}
export -f addGroup

## Frontend to userdel, Displays an error if the user doesn't exist.
delUser() {
	USER=$1
	shift 1
	if grep "^${USER}:" /etc/passwd > /dev/null 2>&1; then
		echo " * Removing User: $USER"
		userdel "$@" $USER
	else
		echo " * User does not exist: $USER [$@]"
	fi
}
export -f delUser

## Frontend to groupdel, Displays an error if the group doesn't exist.
delGroup() {
	GROUP=$1
	shift 1
	if grep "^${GROUP}:" /etc/group > /dev/null 2>&1; then
		echo " * Removing Group: $GROUP"
		groupdel "$@" $GROUP
	else
		echo " * Group does not exist: $GROUP [$@]"
	fi
}
export -f delGroup

####
## Provides an easy access to the init.d scripts within the sys-boot/blfs-bootscripts
## For more information about what scripts are available and how to install them, refer to the
## sys-boot/blfs-bootscripts package.
## This function in essence calls: make install-[name here]
install-init.d() {
	(
		d=$PWD
		PKG=$(DB-getPkg sys-boot/blfs-bootscripts)
		PKG_NAME=$(getName $PKG)
		PKG_VER=$(getVerRev $PKG)
		PKG_BLD="$PKG_DB_DIR/$(getCategory $PKG)/${PKG_NAME}/${PKG_VER}.build"
		unset PATCHES SRC_URI
		checkSha1 ${PKG_BLD%/*} $PKG_BLD || die
		source "${PKG_BLD}"
		BUILD_PATH=$d
		B="${PKG_NAME}-${PKG_VER}"
		prepare_default
		src_install install-$1
	)
}
export -f install-init.d

####
## Functions to compare a version string, modified to print out the error code.
## https://github.com/ruanyf/simple-bash-scripts/blob/master/scripts/versioncompare.sh
function version_gt() { test "$(echo "$@" | tr " " "\n" | sort -V | head -n 1)" != "$1"; echo $?; }
function version_le() { test "$(echo "$@" | tr " " "\n" | sort -V | head -n 1)" == "$1"; echo $?; }
function version_lt() { test "$(echo "$@" | tr " " "\n" | sort -rV | head -n 1)" != "$1"; echo $?; }
function version_ge() { test "$(echo "$@" | tr " " "\n" | sort -rV | head -n 1)" == "$1"; echo $?; }
export -f version_gt version_le version_lt version_ge
