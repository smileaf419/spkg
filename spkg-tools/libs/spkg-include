stripPackage() {
	[[ $RESTRICT == *strip* ]] && return
	cd "${D}"
	echo "Stripping..."
	for s in $( find . -iwholename "*bin/*" -or -iwholename "*/lib*"  ); do
		strip --strip-unneeded "$s" 2> /dev/null && echo " -- $s"
	done
}

archivePackage() {
	# Package it up
	if [[ $BUILD_PACKAGE == "yes" && $ARCHIVE_INSTALL != 1 && $MODE != "bootstrap" ]]; then
		echo -n "Packaging up..."
		mkdir -p "${PKG_ARCHIVE_DIR}/${PKG_CAT}"
		tar -zcpf "${PKG_ARCHIVE_DIR}/${PKG_CAT}/${PKG_NAME}-${PKG_VR}.tar.gz" . && echo " Done"
	fi
}

# Find all Binary deps
getBDeps() {
	[[ $RESTRICT == *nobin* ]] && return
	echo -n "Finding Binary Dependencies..."
	for dep in $( cat $1 | grep -P 'bin/|/lib/|/lib64/|/lib32/|/libx32/'); do
		deps=$(readelf -d $dep 2> /dev/null | grep NEEDED | sed -e 's,.*\[\(.*\)\].*,\1,')
		for d in $deps; do
			for p in $(cat /etc/ld.so.conf); do
				[ -e $p/$d ] && echo $p/$d
			done
		done
	done | sort | uniq > "${PKG_CACHE}/$PKG_CAT/$PKG_NAME/$PKG_VER/BDEPS"
	echo "Done"
}

# Setup package name & version variables
# 1: Package Name
setupENV() {
	PKG=$(DB-getPkg $1 | getLatest)
	if [[ $PKG == "" ]]; then
		PKG=$(DB-getPkgList $1 | fileToList | getLatest)
		if [[ $PKG == "" ]]; then
			return
		fi
	fi
	PKG_CAT=$(getCategory $PKG)
	PKG_NAME=$(getName $PKG)
	PKG_VER=$(getVersion $PKG)
	PKG_REV=$(getRevision $PKG)
	PKG_VR=$(getVerRev $PKG)
	PKG_BLD=$PKG_DB_DIR/${PKG_CAT}/${PKG_NAME}/${PKG_VR}.build
	PKG_NVR=${PKG_NAME}-${PKG_VR}
	PKG_NV=${PKG_NAME}-${PKG_VER}
	PKG_SLOT=$(getSlot $PKG)
	PKG_FLAGS=$(getFlags $PKG)
	BUILD_PATH="${WORKDIR_BASE}/${PKG_NAME}"
	# Default archive build directory
	B="${PKG_NV}"
	# Temp install root
	D="${BUILD_PATH}/troot"
	# Match PKG_SLOT
	O_VER=$(Installed-getPkg $PKG_CAT/$PKG_NAME:$PKG_SLOT | getVerRev)

	# Build a fully Qualified List Entry for data safe-keeping.
	LENTRY="="$PKG_CAT/$PKG_NVR
	if [[ $PKG_SLOT != 0 ]]; then
		LENTRY+=:$PKG_SLOT
	fi
	if [[ ! -z $PKG_FLAGS ]]; then
		LENTRY+=[$PKG_FLAGS]
	fi
	if [ $VERBOSE -ge 3 ]; then
		echo "1          : $1"
		echo "PKG        : $PKG"
		echo "PKG_BLD    : $PKG_BLD"
		echo "PKG_CAT    : $PKG_CAT"
		echo "PKG_NAME   : $PKG_NAME"
		echo "PKG_VER    : $PKG_VER"
		echo "PKG_REV    : $PKG_REV"
		echo "PKG_VR     : $PKG_VR"
		echo "PKG_SLOT   : $PKG_SLOT"
		echo "BUILD_PATH : $BUILD_PATH"
		echo "B          : $B"
		echo "O_VER      : $O_VER"
		echo "PKG_CACHE  : $PKG_CACHE"
		echo "PKG_FLAGS  : $PKG_FLAGS"
		echo "LENTRY     : $LENTRY"
	fi
	export PKG PKG_FLAGS PKG_BLD PKG_CAT PKG_NAME PKG_VER PKG_REV PKG_VR PKG_NV PKG_NVR PKG_SLOT
	export BUILD_PATH B D O_VER LENTRY
}

installList() {
	list=($@)
	length=${#list[@]}
	for (( l=0; l<${length}; l++ ));
	do
		# Current #
		C=$(( ${l} + 1 ))
		p=${list[$l]}
		#TODO add a way to specify a certain version to allow for multiple slots/versions
		#	  to be installed at the same time.
		setupENV $p
	
		# Uninstall
		if [[ $MODE == "uninstall" ]]; then
			echo "Uninstalling ${PKG_CAT}/$PKG_NAME : $O_VER ($C of $length)"
			d=$(isDependedOn ${PKG_CAT}/$PKG_NAME $O_VER)
	
			# FIXME: If uninstalling will break packages Check Forced.
			# Option 1: Uninstall just the requested, breaking other installed packages.
			# Option 2: Uninstall all packages that would break, and any that would break if they were removed.
			# Option 3: Create a Minimal System Requirements package set and disallow any in that list from being
			#			Under any circumstances
			if [[ $d != *$p && $d != "" && $FORCE == 0 ]]; then
				echo "Uninstalling will break packages!"
				echo $d
			else
				(
					source "${PKG_CACHE}/${PKG_CAT}/${PKG_NAME}/${PKG_VER}/${PKG_VER}.build"
					uninstall_default
					uninstall "${PKG_CAT}/${PKG_NAME}" $O_VER ""
					src_post_uninstall
				)
			fi

		# Install
		else
			set -o pipefail
			LOG="${LOGDIR}/$(date +%Y%m%d)-${PKG_NVR}.log"
			CFG_PROTECT=true
			export RESTRICT=

			echo " * ${PKG_CAT}/${PKG_NVR} ($C of $length)"

			TIMESTART=$(date "+%s.%N")

			[[ $SILENT_BUILD == "no" ]] && installPackage 2>&1 | tee $LOG || installPackage > $LOG 2>&1

			[[ -e /usr/bin/bc ]] && echo "Completed in $( echo $(date "+%s.%N") - $TIMESTART | bc ) seconds." | tee -a $LOG

			[ -e $LOG.bz2 ] && rm $LOG.bz2
			bzip2 $LOG
			[ $PIPESTATUS != 0 ] && die "Error installing package: ${PKG_NVR}"
		fi
		echo -n " * Running ldconfig .."
		ldconfig && echo "done!" || echo "failed!"
	done
}

# install doesn't support preserving permissions
# and ownership, so we need to get them and 
# explicitly set them.
sinstall() {
	local d=
	[ -d "$1" ] && d="-d"
	eval install $d $(stat -c '-m%a -g%g -o%u' "$1") \"$1\" \"$2\"
}
