stripPackage() {
	[[ $RESTRICT == *strip* ]] && return
	cd "${D}"
	echo "Stripping..."
	for s in $( find . -iwholename "*bin/*" -or -iwholename "*/lib*"  ); do
		strip --strip-unneeded "$s" 2> /dev/null && echo " -- $s"
	done
}

archivePackage() {
	# Package it up
	if [[ $BUILD_PACKAGE == "yes" && $ARCHIVE_INSTALL != 1 && $MODE != "bootstrap" ]]; then
		echo -n "Packaging up..."
		mkdir -p "${PKG_ARCHIVE_DIR}/${PKG_CAT}"
		tar -zcpf "${PKG_ARCHIVE_DIR}/${PKG_CAT}/${PKG_NAME}-${PKG_VR}.tar.gz" . && echo " Done"
	fi
}

# Find all Binary deps
getBDeps() {
	[[ $RESTRICT == *nobin* ]] && return
	echo -n "Finding Binary Dependencies..."
	for dep in $( cat $1 | grep -P 'bin/|/lib/|/lib64/|/lib32/|/libx32/'); do
		deps=$(readelf -d $dep 2> /dev/null | grep NEEDED | sed -e 's,.*\[\(.*\)\].*,\1,')
		for d in $deps; do
			for p in $(cat /etc/ld.so.conf); do
				[ -e $p/$d ] && echo $p/$d
			done
		done
	done | sort | uniq > "${PKG_CACHE}/$PKG_CAT/$PKG_NAME/$PKG_VER/BDEPS"
	echo "Done"
}

# 1: Package Name
setupENV() {
	# If the PKG changes, its Ok to reset the PKG_FLAGS
	TPKG=$(getpkg ${1%[*})
	if [[ $TPKG != $PKG && $1 == *[* ]]; then
		PKG_FLAGS=${1#*[}
		PKG_FLAGS=${PKG_FLAGS%]}
	fi
	PKG=$TPKG
	PKG_BLD=$PKG_DB_DIR/${PKG}.build
	PKG_CAT=$(getcategory $PKG)
	PKG_NAME=$(getpkgname $PKG)
	PKG_VER=$(getpkgver $PKG)
	PKG_REV=$(getpkgrev $PKG)
	PKG_VR=$(getpkgvr $PKG)
	BUILD_PATH="${WORKDIR_BASE}/${PKG_NAME}"
	# Default archive build directory
	B="${PKG_NAME}-${PKG_VER}"
	# Temp install root
	D="${BUILD_PATH}/troot"
	O_VER=$(getinstalledversion $PKG_CAT/$PKG_NAME)
	if [ $VERBOSE -ge 3 ]; then
		echo "1          : $1"
		echo "PKG        : $PKG"
		echo "PKG_BLD    : $PKG_BLD"
		echo "PKG_CAT    : $PKG_CAT"
		echo "PKG_NAME   : $PKG_NAME"
		echo "PKG_VER    : $PKG_VER"
		echo "PKG_REV    : $PKG_REV"
		echo "PKG_VR     : $PKG_VR"
		echo "BUILD_PATH : $BUILD_PATH"
		echo "B          : $B"
		echo "O_VER      : $O_VER"
		echo "PKG_CACHE  : $PKG_CACHE"
		echo "PKG_FLAGS  : $PKG_FLAGS"
	fi
	export PKG PKG_FLAGS PKG_BLD PKG_CAT PKG_NAME PKG_VER PKG_REV PKG_VR BUILD_PATH B D O_VER
}

installList() {
	list=($@)
	length=${#list[@]}
	for (( l=0; l<${length}; l++ ));
	do
		# Current #
		C=$(( ${l} + 1 ))
		p=${list[$l]}
		#TODO add a way to specify a certain version to allow for multiple slots/versions
		#	  to be installed at the same time.
		setupENV $p
	
		# Uninstall
		if [[ $MODE == "uninstall" ]]; then
			echo "Uninstalling ${PKG_CAT}/$PKG_NAME : $O_VER ($C of $length)"
			# TODO: Before we do an Uninstall, Check for any Binary Dependency.
			d=$(isDependedOn ${PKG_CAT}/$PKG_NAME $O_VER)
	
			# FIXME: If uninstalling will break packages Check Forced.
			# Option 1: Uninstall just the requested, breaking other installed packages.
			# Option 2: Uninstall all packages that would break, and any that would break if they were removed.
			# Option 3: Create a Minimal System Requirements package set and disallow any in that list from being
			#			Under any circumstances
			if [[ $d != *$p && $d != "" && $FORCE == 0 ]]; then
				echo "Uninstalling will break packages!"
				echo $d
			else
				(
					source "${PKG_CACHE}/${PKG_CAT}/${PKG_NAME}/${PKG_VER}/${PKG_VER}.build"
					src_uninstall
					uninstall "${PKG_CAT}/${PKG_NAME}" $O_VER ""
					src_post_uninstall
				)
			fi
			
		# Install
		else
			set -o pipefail
			LOG="${LOGDIR}/$(date +%Y%m%d)-${PKG_NAME}-${PKG_VR}.log"
			CFG_PROTECT=true
			export RESTRICT=
			
			echo " * ${PKG_CAT}/${PKG_NAME}-${PKG_VR} ($C of $length)"

			TIMESTART=$(date "+%s.%N")

			[[ $SILENT_BUILD == "no" ]] && installPackage | tee $LOG 2>&1 || installPackage > $LOG 2>&1

			[[ -e /usr/bin/bc ]] && echo "Completed in $( echo $(date "+%s.%N") - $TIMESTART | bc ) seconds." | tee -a $LOG

			[ -e $LOG.bz2 ] && rm $LOG.bz2
			bzip2 $LOG 
			[ $PIPESTATUS -eq 0 ] || die "Error installing package: ${PKG_NAME}-${PKG_VR}"
		fi
		echo -n " * Running ldconfig .."
		ldconfig && echo "done!" || echo "failed!"
	done
}

# install doesn't support preserving permissions
# and ownership, so we need to get them and 
# explicitly set them.
sinstall() {
	# had to break the stat command up into 3 parts
	# to avoid install from assuming the 3 switches 
	# were all 1 switch.
	# Assuming rather than interpretating the command
	# it directly sent the arguments to install.
	P=$(stat -c '-m%a' "$1")
	G=$(stat -c '-g%g' "$1")
	O=$(stat -c '-o%u' "$1")
	if [ -d "$1" ]; then
		install -d $P $O $G "$1" "$2"
	else
		install $P $O $G "$1" "$2"
	fi
}

fetch_files() {
	SRC_FILES=($1)
	echo ${SRC_FILES[@]}
}
