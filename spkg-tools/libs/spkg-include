#!/bin/bash
####
## Defines functions not organized/categorized into other files

## Create an archive package of our build, could be useful if we decide to distribute binary copies
## Enabled with BUILD_PACKAGE = yes
archivePackage() {
	# Package it up
	if [[ $BUILD_PACKAGE == "yes" && $ARCHIVE_INSTALL != 1 && $MODE != "bootstrap" ]]; then
		echo -n "Packaging up..."
		mkdir -p "${PKG_ARCHIVE_DIR}/${PKG_CAT}"
		tar -Jcpf "${PKG_ARCHIVE_DIR}/${PKG_CAT}/${PKG_NAME}-${PKG_VR}.tar.xz" . && echo " Done"
	fi
}

## Remove unneccessary symbols to reduce the filesize in binaries.
## Packages may disable this with RESTRICT=strip
stripPackage() {
	pkg-restricts strip && return
	cd "${D}"
	echo "Stripping..."
	for s in $( find . -iwholename "*bin/*" -or -iwholename "*/lib*" ); do
		strip --strip-unneeded "$s" 2> /dev/null && echo " -- $s"
	done
}

## Find all binary dependencies
## Packages may disable this with RESTRICT=nobin
getBDeps() {
	pkg-restricts nobin && return
	echo -n "Finding Binary Dependencies..."
	for dep in $( cat $1 | grep -P 'bin/|/lib/|/lib64/|/lib32/|/libx32/'); do
		deps=$(readelf -d $dep 2> /dev/null | grep NEEDED | sed -e 's,.*\[\(.*\)\].*,\1,')
		for d in $deps; do
			for p in $(cat /etc/ld.so.conf); do
				[ -e $p/$d ] && echo $p/$d
			done
		done
	done | sort | uniq > "${PKG_CACHE}/$PKG_CAT/$PKG_NAME/$PKG_VER/BDEPS"
	echo "Done"
}

####
## Takes a list of PKG to (un)install
installList() {
	local list=($@)
	local length=${#list[@]}

	## Linux-kernel uses the ARCH environment var, rename it and unset the ARCH to avoid issues.
	## FIXME: This should probably be changed internally rather than be arbitrarily renamed.
	export SARCH=$ARCH
	unset ARCH

	for (( l=0; l<${length}; l++ )); do
		## Current #
		local C=$(( ${l} + 1 ))
		## PKG entry
		local p=${list[$l]}
		setupENV $p

		## Uninstall
		if [[ $MODE == "uninstall" ]]; then
			echo "Uninstalling ${PKG_CAT}/$PKG_NAME : $O_VER ($C of $length)"
			(
				source $(getBldFile $p 1)
				local d=$(isDependedOn ${PKG_CAT}/$PKG_NAME $O_VER)

				## FIXME: If uninstalling will break packages Check Forced.
				## Option 1: Uninstall just the requested, breaking other installed packages.
				## Option 2: Uninstall all packages that would break, and any that would break if they were removed.
				## Option 3: Create a Minimal System Requirements package set and disallow any in that list from being
				##           removed under any circumstances.
				if [[ $d != *$p && $d != "" && $FORCE == 0 ]]; then
					echo "Uninstalling will break packages!"
					echo $d
				else
					## pre-uninstall code if needed/set
					uninstall_default
					## Uninstall the package
					uninstall "${PKG_CAT}/${PKG_NAME}" $O_VER ""
					## post-uninstall code if needed/set
					src_post_uninstall
				fi
			)

		## Install
		else
			####
			## Set the log file
			## Can alter this to use a LOGFILE using
			## %c category  %d day   %D date (%Y%m%d)  %s Unix Timestamp
			## %n name      %Y year  %m month          %v version with revision
			LOGFILE=${LOGFILE:-%D-%n%v%r.log}

			local log=$(echo $LOGDIR/$LOGFILE |
				sed -e "s,%c,$PKG_CAT," \
					-e "s,%n,$PKG_NAME," \
					-e "s,%v,$PKG_VR,"    \
					-e "s,%s,$(date +%s)," \
					-e "s,%d,$(date +%d)," \
					-e "s,%m,$(date +%m)," \
					-e "s,%Y,$(date +%Y)," \
					-e "s,%D,$(date +%Y%m%d),")

			## Our log may contain a directory or 2
			mkdir -p "${log%/*}"

			## If the file exists, append a unix timestamp to the end.
			[[ -e $log || -e $log.xz ]] && log="${log%.*}-$(date +%s).log"

			CFG_PROTECT=true

			export RESTRICT=

			echo " * ${PKG_CAT}/${PKG_NVR} ($C of $length)"

			## Save what time we started installing so we can output how long it took at the end.
			local timestart=$(date "+%s.%N")

			if [[ $SILENT_BUILD == "no" ]]; then
				set -o pipefail
				installPackage 2>&1 | tee $log
				[ $PIPESTATUS != 0 ] && die "Error installing package: ${PKG_NVR}"
			else
				installPackage > $log 2>&1 || die "Error installing package: ${PKG_NVR}"
			fi

			## If bc is installed output how long it took to build
			if [[ -e /usr/bin/bc ]]; then
				printf "Completed in %.3f seconds.\n" $( echo $(date "+%s.%N") - $timestart | bc ) | tee -a $log
			fi

			## Compress our log.
			[[ ! -e "${log}.xz" ]] && xz "$log" || echo " ! Log ${log}.xz exists"
		fi
		echo -n " * Running ldconfig .."
		ldconfig && echo "done!" || echo "failed!"
	done
}
