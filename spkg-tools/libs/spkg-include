## Create an archive package of our build, could be useful if we decide to distribute binary copies
## Enabled with BUILD_PACKAGE = yes
archivePackage() {
	# Package it up
	if [[ $BUILD_PACKAGE == "yes" && $ARCHIVE_INSTALL != 1 && $MODE != "bootstrap" ]]; then
		echo -n "Packaging up..."
		mkdir -p "${PKG_ARCHIVE_DIR}/${PKG_CAT}"
		tar -Jcpf "${PKG_ARCHIVE_DIR}/${PKG_CAT}/${PKG_NAME}-${PKG_VR}.tar.xz" . && echo " Done"
	fi
}

## Remove unneccessary symbols to reduce the filesize in binaries.
## Packages may disable this with RESTRICT=strip
stripPackage() {
	pkg-restricts strip && return
	cd "${D}"
	echo "Stripping..."
	for s in $( find . -iwholename "*bin/*" -or -iwholename "*/lib*" ); do
		strip --strip-unneeded "$s" 2> /dev/null && echo " -- $s"
	done
}

## Find all binary dependencies
## Packages may disable this with RESTRICT=nobin
getBDeps() {
	pkg-restricts nobin && return
	echo -n "Finding Binary Dependencies..."
	for dep in $( cat $1 | grep -P 'bin/|/lib/|/lib64/|/lib32/|/libx32/'); do
		deps=$(readelf -d $dep 2> /dev/null | grep NEEDED | sed -e 's,.*\[\(.*\)\].*,\1,')
		for d in $deps; do
			for p in $(cat /etc/ld.so.conf); do
				[ -e $p/$d ] && echo $p/$d
			done
		done
	done | sort | uniq > "${PKG_CACHE}/$PKG_CAT/$PKG_NAME/$PKG_VER/BDEPS"
	echo "Done"
}

## Setup package Environmental Variables
## Requires a LENTRY or at minimum PKG_NAME
setupENV() {
	if [[ $MODE == 'uninstall' ]]; then
		PKG=$(Installed-getPkg $1)
	else
		PKG=$(DB-getPkg $1 | getLatest)
	fi
	if [[ $PKG == "" ]]; then
		PKG=$(DB-getPkgList $1 | fileToList | getLatest)
		if [[ $PKG == "" ]]; then
			return
		fi
	fi
	PKG_CAT=$(getCategory $PKG)
	PKG_NAME=$(getName $PKG)
	PKG_VER=$(getVersion $PKG)
	PKG_REV=$(getRevision $PKG)
	PKG_VR=$(getVerRev $PKG)
	if [[ $MODE == 'uninstall' ]]; then
		PKG_BLD=$PKG_CACHE/${PKG_CAT}/${PKG_NAME}/${PKG_VR}/${PKG_VR}.build
	else
		PKG_BLD=$PKG_DB_DIR/${PKG_CAT}/${PKG_NAME}/${PKG_VR}.build
	fi
	PKG_NVR=${PKG_NAME}-${PKG_VR}
	PKG_NV=${PKG_NAME}-${PKG_VER}
	PKG_SLOT=$(getSlot $PKG)
	PKG_FLAGS=$(getFlags $PKG)
	BUILD_PATH="${WORKDIR_BASE}/${PKG_NAME}"
	## Default archive build directory
	B="${PKG_NV}"
	## Temp install root
	D="${BUILD_PATH}/troot"
	## Installed version filtered by PKG_SLOT
	O_VER=$(Installed-getPkg $PKG_CAT/$PKG_NAME:$PKG_SLOT | getVerRev)

	## Build a fully Qualified List Entry for data safe-keeping.
	## Might change this to a / seperated list and use this for a nice display value.
	LENTRY="="$PKG_CAT/$PKG_NVR
	if [[ $PKG_SLOT != 0 ]]; then
		LENTRY+=:$PKG_SLOT
	fi
	if [[ ! -z $PKG_FLAGS ]]; then
		LENTRY+=[$PKG_FLAGS]
	fi
	if [ $VERBOSE -ge 3 ]; then
		echo "1          : $1"
		echo "PKG        : $PKG"
		echo "PKG_BLD    : $PKG_BLD"
		echo "PKG_CAT    : $PKG_CAT"
		echo "PKG_NAME   : $PKG_NAME"
		echo "PKG_VER    : $PKG_VER"
		echo "PKG_REV    : $PKG_REV"
		echo "PKG_VR     : $PKG_VR"
		echo "PKG_SLOT   : $PKG_SLOT"
		echo "BUILD_PATH : $BUILD_PATH"
		echo "B          : $B"
		echo "O_VER      : $O_VER"
		echo "PKG_CACHE  : $PKG_CACHE"
		echo "PKG_FLAGS  : $PKG_FLAGS"
		echo "LENTRY     : $LENTRY"
	fi
	export PKG PKG_FLAGS PKG_BLD PKG_CAT PKG_NAME PKG_VER PKG_REV PKG_VR PKG_NV PKG_NVR PKG_SLOT
	export BUILD_PATH B D O_VER LENTRY
}

####
## Takes a list of LENTRY to (un)install
installList() {
	list=($@)
	length=${#list[@]}
	for (( l=0; l<${length}; l++ ));
	do
		## Current #
		C=$(( ${l} + 1 ))
		## PKG entry
		p=${list[$l]}
		setupENV $p
	
		## Uninstall
		if [[ $MODE == "uninstall" ]]; then
			echo "Uninstalling ${PKG_CAT}/$PKG_NAME : $O_VER ($C of $length)"
			(
				source "${PKG_CACHE}/${PKG_CAT}/${PKG_NAME}/${PKG_VER}/${PKG_VER}.build"
				d=$(isDependedOn ${PKG_CAT}/$PKG_NAME $O_VER)
	
				## FIXME: If uninstalling will break packages Check Forced.
				## Option 1: Uninstall just the requested, breaking other installed packages.
				## Option 2: Uninstall all packages that would break, and any that would break if they were removed.
				## Option 3: Create a Minimal System Requirements package set and disallow any in that list from being
				##           removed under any circumstances.
				if [[ $d != *$p && $d != "" && $FORCE == 0 ]]; then
					echo "Uninstalling will break packages!"
					echo $d
				else
					## pre-uninstall code if needed/set
					uninstall_default
					## Uninstall the package
					uninstall "${PKG_CAT}/${PKG_NAME}" $O_VER ""
					## post-uninstall code if needed/set
					src_post_uninstall
				fi
			)

		## Install
		else
			####
			## Set the log file
			## Can alter this to use a LOGFILE using
			## %c category  %d day   %D date (%Y%m%d)  %s Unix Timestamp
			## %n name      %Y year  %m month          %v version with revision
			LOGFILE=${LOGFILE:-%D-%n%v%r.log}

			LOG=$(echo $LOGDIR/$LOGFILE |
				sed -e "s,%c,$PKG_CAT," \
					-e "s,%n,$PKG_NAME," \
					-e "s,%v,$PKG_VR,"    \
					-e "s,%s,$(date +%s)," \
					-e "s,%d,$(date +%d)," \
					-e "s,%m,$(date +%m)," \
					-e "s,%Y,$(date +%Y)," \
					-e "s,%D,$(date +%Y%m%d),")

			## Our LOG may contain a directory or 2
			mkdir -p "${LOG%/*}"

			## If the file exists, append a unix timestamp to the end.
			[[ -e $LOG || -e $LOG.xz ]] && LOG="${LOG%.*}-$(date +%s).log"

			CFG_PROTECT=true

			export RESTRICT=

			echo " * ${PKG_CAT}/${PKG_NVR} ($C of $length)"

			## Save what time we started installing so we can output how long it took at the end.
			TIMESTART=$(date "+%s.%N")

			if [[ $SILENT_BUILD == "no" ]]; then
				set -o pipefail
				installPackage 2>&1 | tee $LOG
				[ $PIPESTATUS != 0 ] && die "Error installing package: ${PKG_NVR}"
			else
				installPackage > $LOG 2>&1 || die "Error installing package: ${PKG_NVR}"
			fi

			## If bc is installed output how long it took to build
			if [[ -e /usr/bin/bc ]]; then
				printf "Completed in %.3f seconds.\n" $( echo $(date "+%s.%N") - $TIMESTART | bc ) | tee -a $LOG
			fi

			## Compress our log.
			xz "$LOG"
		fi
		echo -n " * Running ldconfig .."
		ldconfig && echo "done!" || echo "failed!"
	done
}

####
## install doesn't support preserving permissions
## and ownership, so we need to get them and
## explicitly set them.
sinstall() {
	local d=
	[ -d "$1" ] && d="-d"
	eval install $d $(stat -c '-m%a -g%g -o%u' "$1") \"$1\" \"$2\"
}
