#!/bin/bash
####
## Contains Utility functions used in all aspects of package management.
## kernel utilities such as buildKernel, setKernelConfig
## Fetching utilities: fetch_file, fetch_list
## checkSha1
## sinstall
## preservedRebuild
## buildBDeps

####
## Set a Kernel config file
## As we set this here, its possible to override it later.
KERNEL_CONFIG_FILE=/usr/src/linux/.config

####
## Set a Kernel config value
## Would be nice all vars exist and if not set, set to blank
## VAR=   This is not set
## VAR="" This is an empty set value
## Sadly this is not the case, so the logic is much more in-depth.
setKernelConfig() {
	local var=$1
	local val=$2

	if grep -E "(^|[[:space:]])${var}(=|[[:space:]])" $KERNEL_CONFIG_FILE > /dev/null; then
		sed -i "/\(^\| \)$var\(=\| \)/ s,^.*$,$var=$val," $KERNEL_CONFIG_FILE
	else
		## We need to append the var=val
		echo "$var=$val" >> $KERNEL_CONFIG_FILE
	fi
}

####
## This requires a /usr/src/linux symlink to our kernel
## and either a .config within the directory OR /proc/config.gz to be enabled within our running kernel.
##
## Auto mounting of /boot is available
## vmlinuz and System.map will be renamed to match the kernel version.
## a grub config will also be automatically be generated.
buildKernel() {
	local SPKG_ARCH=$ARCH
	local SPKG_INSTALL_PATH=$INSTALL_PATH
	unset ARCH INSTALL_PATH
	## Detect our config file
	[ ! -e /usr/src/linux ] && die "you should set your /usr/src/linux symlink to a valid kernel source."
	if [[ ! -e $KERNEL_CONFIG_FILE && ! -e /proc/config.gz ]]; then
		echo "Cannot Build kernel without either a /proc/config.gz or a $KERNEL_CONFIG_FILE"
		die "Please go to /usr/src/linux and run: make menuconfig"
	fi
	if [[ -e /proc/config.gz && ! -e $KERNEL_CONFIG_FILE ]]; then
		gzip -cd /proc/config.gz > $KERNEL_CONFIG_FILE
		echo " * Using current running kernel's config"
	fi

	## Get our kernel version from the symlink.
	KERNEL_VER=$(readlink -f /usr/src/linux | sed -e 's,.*linux-,,' -e 's,/$,,')
	echo " * Building Kernel - $KERNEL_VER"

	cd /usr/src/linux

	####
	## Set some default config values here

	## Set the default init to OpenRC.
#	setKernelConfig CONFIG_DEFAULT_INIT '"/sbin/openrc-init"'
	setKernelConfig CONFIG_IKCONFIG y
	setKernelConfig CONFIG_IKCONFIG_PROC y

	echo " * Running: make oldconfig"
	make oldconfig
	echo " * Compiling (using: $MAKEOPTS)"
	make $MAKEOPTS

	## Mount /boot if it exists
	if [[ ! -z $(grep /boot /etc/fstab) && -z $(mount | grep /boot) ]]; then
		echo " * Mounting /boot"
		mount /boot
		BOOT_MOUNTED=1
	fi
	echo " * Installing."
	make install modules_install
	mv /boot/System.map{,-${KERNEL_VER}}
	mv /boot/vmlinuz{,-${KERNEL_VER}}

	echo " * Generating grub config"
	grub-mkconfig -o /boot/grub/grub.cfg
	if [[ ! -z $BOOT_MOUNTED ]]; then
		echo " * Unmounting /boot"
		umount /boot
	fi
	export ARCH=$SPKG_ARCH
	export INSTALL_PATH=$SPKG_INSTALL_PATH
}

####
## Check the WORLD file for a PKG
## Returns nothing, if nothing is found.
getPkgFromWorld() {
	[ -z $PKG_WORLD ] && die "Error: World File not set"
    grep "^$1" $PKG_WORLD 2> /dev/null || echo $PKG
}

####
## Adds an Entry to our INSTALL_CHART
Install-addPkg() {
#	PKG_LIST+=" $1"
	eval echo $1 >> $INSTALL_CHART
}

####
## Gather a list of packages based on what type of module we're needing to rebuild.
rebuildModules() {
	local type=$1
	case $type in
		kernel)
			type=KERNEL_MODULE ;;
		perl)
			type=PERL_MODULE ;;
		python)
			type=PYTHON_MODULE ;;
	esac
	for m in $(find ${PKG_CACHE} -iname $type | sed -e "s,/$type,," -e "s,${PKG_CACHE}/,,")
	do
		echo -n "$(getCategory $m)/$(getName $m) "
	done
}

####
## Build Dependencies
## There are a few types of Dependencies
## 1) Run time (RDEPS)
## 2) Build time (BDEPS)
## 3) Binary (DEPS)
## 4) USE flag Dependencies (UDEPS)
## 5) Circular Dependencies (CDEPS)
##
## Because dependencies can change across versions, This
## will only update the BDEPS of the installed package.
buildBDeps() {
	local OUT=

	## Use our BDEPS file installed within PKG_CACHE
	Installed-getPkg $1 > /dev/null

	[ $VERBOSE -ge 1 ] && echo -n "$PKG_CAT/$PKG_NVR ( "

	## Filter out the Toolchain. These are always depended on,
	## So we don't need it complicating the logic
	PKG_FILTER=("sys-apps/util-linux" "sys-libs/glibc" "sys-devel/gcc")

	(
		source "$PKG_BLD"
		if pkg-restricts "nobin"; then
			[ $VERBOSE -ge 1 ] && echo " none )"
			return 0
		fi

		PKG_FILTER+=(${CDEPS[@]})
		## For this to work properly we need to save our USE flag and set it to this prior to sourcing
		## If the user changes it after its been installed, it may skew the results.
		PKG_FILTER+=(${UDEPS[@]})

		## Force a refresh of the BDEPS file.
		if [[ $FORCE == 1 ]]; then
			getBDeps "$PKG_CACHE/$PKG/CONTENTS"
		fi

		## Itterate over it and find matching files within each package's CONTENTS
		for dep in $(cat "$PKG_CACHE/$PKG_CAT/$PKG_NAME/$PKG_VR/BDEPS"); do
			## readlink to resolve relative paths that occationally show up.
			## use dirname first in case the file is a symlink
			dep=$(readlink -f $(dirname $dep))/${dep##*/}

			## Grab a list of category/PKG names for each file.
			## It is possible for multiple results to occur.
			O=$(grep -r --include=CONTENTS "^$dep$" $PKG_CACHE |
				sed -e 's,:.*,,' \
				    -e "s,$PKG_CACHE/,," \
				    -e 's,/CONTENTS,,' \
					-e 's,\(.*/.*\)/.*,\1,')
			## No package found for the file.
			if [[ -z $O ]]; then
				>&2 echo " !! $dep Not found in any package"
				continue
			fi
			## Filter out itself.
			[[ "$PKG_CAT/$PKG_NAME" == "$O" ]] && continue

			## If its not within our filter, or already added, add it to the list.
			if [[ ! ${PKG_FILTER[*]} =~ (^|[[:space:]]|=|>|<)"$O"($|[[:space:]]|:|-[0-9]) &&
				  ! $OUT =~ (^|[[:space:]])"$O"($|[[:space:]]) ]]; then
				OUT+=" $O"
				[ $VERBOSE -ge 1 ] && echo -n "$O '$d' "
			fi
		done

		[ $VERBOSE -ge 1 ] && echo ")"
		## Filter out duplicates we didn't catch earlier.
		D=$(echo $OUT|tr ' ' '\n'|sort|uniq|tr '\n' ' ')
		## Trim the space at the end for cosmetic reasoning.
		D=${D%% }
		## Dependencies
		if ! grep '^DEPS=' $PKG_BLD > /dev/null 2>&1; then
			echo -n "DEPS Missing - checking for BDEPS: "
			if grep '^BDEPS=' $PKG_BLD > /dev/null 2>&1; then
				echo "Updating."
				sed -i 's,^BDEPS=["'\'']\(.*\)\["'\''],DEPS=\"\1\"\nBDEPS=\"\",' $PKG_BLD
			else
				echo "Not found, Skipping.."
				continue
			fi
		fi

		## Theoretically speaking sorting is wasted if this is exclusively used
		## to add DEPS, but this isn't always the case.
		## sort things to avoid false-positives
		LD=$(grep '^DEPS=' $PKG_BLD | sed -e 's,^DEPS=["'\''],,' -e 's,["'\''].*,,'|tr ' ' '\n'|sort|uniq|tr '\n' ' ')

		## If any need updating
		if [[ ${LD%% } != $D ]]; then
			AD=
			for l in $D; do
				if [[ ! $LD =~ (^|[[:space:]])"$l"($|[[:space:]]) ]]; then
					AD+=" $l"
				fi
			done
			RD=
			for l in $LD; do
				if [[ ! $D =~ (^|[[:space:]])"$l"($|[[:space:]]) ]]; then
					RD+=" $l"
				fi
			done

			echo " * Updating $PKG_CAT/$PKG_NVR:"
			[[ ! -z $AD ]] && echo "  - Added:$AD"
			[[ ! -z $RD ]] && echo "  - Removed:$RD"
			if [[ $PRETEND != 1 ]]; then
				sed -i "s,^DEPS=[\"'].*[\"'],DEPS=\"${D}\"," $PKG_BLD
			fi
		fi

	)
	HASH_UPDATE=true
}

## Fetch a file from a given address
## Optionally save it under a given name.
fetch_file() {
	## Just Ignore Empty calls.
	[[ $1 == "" ]] && return 0
	FILE=${1##*/}
	OUTFILE=$2

	## No custom outfile .. just save it as normal
	[[ $OUTFILE == "" ]] && OUTFILE=$FILE

	## If we already exist, ignore it
	[ -e "${DISTFILES}/${OUTFILE}" ] && return 0
	wget -c -O "${DISTFILES}/${OUTFILE}" "$1"

	## If we encounter an Error, delete the file and error out.
	if [ $? != 0 ]; then
		[[ -e "$DISTFILES/$OUTFILE" ]] && rm "${DISTFILES}/${OUTFILE}"
		echo "   FILE: $FILE"
		echo "OUTFILE: $OUTFILE"
		echo "1: $1"
		echo "2: $2"
		die "Error Downloading";
	fi
}

####
## Fetch a list of files
## Requires 1: A Message to output
##          2: A \n seperated list of files to fetch
##          3: Optionally if 'src' or 'patch' is supplied, it will update the variables altering their filename to the renamed value.
##          4: Optionally supply 1 to update the sha1sum if the hash fails and save it within the package's sha1 file within its directory.
##             Requires a PKG_BLD be set
fetch_list() {
	## Output our message
	[[ ! -z $1 ]] && echo $1
	local IFS=$'\n'
	local list=($2)
	## Used in --updatesha1
	local update_sha=${4:-0}

	local length=${#list[@]}
	local ret=0
	for (( l=0; l<${length}; l++ )); do
		C=$(( $l + 1 ))
		file=${list[$l]}
		[[ $VERBOSE -ge 2 ]] && echo " * Fetching $C of $length: $file"
		[[ $file == "" ]] && continue
		if [[ $file =~ (^|[[:space:]])"=>"($|[[:space:]]) ]]; then
			local SRC_OUTFILE=${file/*=> /}
			local SRC_FILE=${file/ =>*/}
			# Once a fetch occurs we don't actually need the old filename.
			# Rename it so as to avoid confusion later.
			if [[ $3 == 'src' ]]; then
				SRC_URI[$l]="${SRC_FILE%/*}/${SRC_OUTFILE}"
			elif [[ $3 == 'patch' ]]; then
				PATCHES[$l]="${SRC_FILE%/*}/${SRC_OUTFILE}"
			fi
		else
			local SRC_FILE=$file
			local SRC_OUTFILE=${SRC_FILE##*/}
		fi
		if [ ! -f "${DISTFILES}/${SRC_OUTFILE}" ]; then
			echo "Fetching ($C of $length) $SRC_FILE"
			fetch_file "$SRC_FILE" "$SRC_OUTFILE"
		fi
		if ! checkSha1 ${PKG_BLD%/*} "$DISTFILES/$SRC_OUTFILE"; then
			if [[ $IGNORE_SHA == 1 ]]; then
				ret=2
			elif [[ $update_sha == 1 ]]; then
				sha1sum "$DISTFILES/$SRC_OUTFILE" | sed 's,  .*/,  ,' >> ${PKG_BLD%/*}/sha1
			else
				[[ $VERBOSE -gt 1 ]] && >&2 echo " !! Sha1sum failed for file: $SRC_OUTFILE"
				ret=1
			fi
		fi
	done
	return $ret
}

## Check a sha1sum of a given file within the package's sha1 file.
checkSha1() {
	[[ $IGNORE_SHA1 == 1 || $MODE == 'uninstall' ]] && return 0
	local PKG_DIR=$1
	local FILE=$2

	## Ignore Empty calls
	[[ $FILE == "" ]] && return 0
	[[ ! -e $PKG_DIR/sha1 ]] && return 1

	[[ $VERBOSE -ge 2 ]] && >&2 echo -n "Checking Sha1: $FILE ... "
	[ ! -e $FILE ] && echo "Failed checking $PKG sha1" && return 1
	local h=$(sha1sum $FILE | sed 's,  .*/,  ,' 2> /dev/null)
	[[ $VERBOSE -ge 2 ]] && >&2 echo -n $h
	if grep "$h" $PKG_DIR/sha1 > /dev/null 2>&1; then
		[[ $VERBOSE -ge 2 ]] && >&2 echo " ..Ok"
	else
		return 1
	fi
	return 0
}

####
## install doesn't support preserving permissions
## and ownership, so we need to get them and
## explicitly set them.
sinstall() {
	local d=
	[ -d "$1" ] && d="-d"
	eval install $d $(stat -c '-m%a -g%g -o%u' "$1") \"$1\" \"$2\"
}

####
## Gathers a list of packages based on files found within PERSERVED_LOG to install them.
## PERSERVED_LOG is generated during the uninstall phase of a pkg upgrade or uninstall
## and contains files which are depended on packages still installed.
## Once the rebuild is complete the now obsolete files are removed.
preservedRebuild() {
	MODE='rebuild'
	## Files were preserved, process them here to ensure we don't break our system.
	if [ -e $PRESERVED_LOG ]; then
		echo " * Gathering list of packages to rebuild"
		[ -e $INSTALL_CHART ] && rm $INSTALL_CHART
		PKG_LIST=
		REQUESTED_LIST=
		for f in $(cat $PRESERVED_LOG); do
			echo -n "$f:"
			local pkgs=$(checkFileDep $f | sort|uniq|tr '\n' ' ')
			echo " $pkgs"
			for d in $pkgs; do
				#  B=${A%/*}; C=${A##*/}; echo $B-$C
				local cn=${d%/*}
				local v=${d##*/}
				setPkgENV $cn-$v > /dev/null
				setupENV $PKG > /dev/null
				echo $PKG_CAT/$PKG_NAME-$PKG_VR:$PKG_SLOT
				Install-addPkg $PKG
			done
		done

		installList $PKG_LIST
		for f in $(cat $PRESERVED_LOG); do
			rm "$f" 2> /dev/null && echo " << $f" || echo " <! $f"
		done
		rm $PRESERVED_LOG
	fi
}
