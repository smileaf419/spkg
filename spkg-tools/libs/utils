#!/bin/bash
####
## Set a Kernel config file
## As we set this here, its possible to override it later.
KERNEL_CONFIG_FILE=/usr/src/linux/.config

####
## Set a Kernel config value
## Would be nice all vars exist and if not set, set to blank
## VAR=   This is not set
## VAR="" This is an empty set value
## Sadly this is not the case, so the logic is much more in-depth.
setKernelConfig() {
	local var=$1
	local val=$2

	if grep -E "(^|[[:space:]])${var}(=|[[:space:]])" $KERNEL_CONFIG_FILE; then
		sed -i "/\(^\| \)$var\(=\| \)/ s,^.*$,$var=$val," $KERNEL_CONFIG_FILE
	else
		## We need to append the var=val
		echo "$var=$val" >> $KERNEL_CONFIG_FILE
	fi
}

####
## This requires a /usr/src/linux symlink to our kernel
## and either a .config within the directory OR /proc/config.gz to be enabled within our running kernel.
##
## Auto mounting of /boot is available
## vmlinuz and System.map will be renamed to match the kernel version.
## a grub config will also be automatically be generated.
buildKernel() {
	## Detect our config file
	[ ! -e /usr/src/linux ] && die "you should set your /usr/src/linux symlink to a valid kernel source."
	if [[ ! -e $KERNEL_CONFIG_FILE && ! -e /proc/config.gz ]]; then
		echo "Cannot Build kernel without either a /proc/config.gz or a $KERNEL_CONFIG_FILE"
		die "Please go to /usr/src/linux and run: make menuconfig"
	fi
	if [[ -e /proc/config.gz && ! -e $KERNEL_CONFIG_FILE ]]; then
		gzip -cd /proc/config.gz > $KERNEL_CONFIG_FILE
		echo " * Using current running kernel's config"
	fi

	## Get our kernel version from the symlink.
	KERNEL_VER=$(readlink /usr/src/linux | sed -e 's,.*linux-,,' -e 's,/$,,')
	echo " * Building Kernel - $KERNEL_VER"
	
	cd /usr/src/linux

	####
	## Set some default config values here

	## Set the default init to OpenRC.
#	setKernelConfig CONFIG_DEFAULT_INIT '"/sbin/openrc-init"'
	setKernelConfig CONFIG_IKCONFIG y
	setKernelConfig CONFIG_IKCONFIG_PROC y

	echo " * Running: make oldconfig"
	make oldconfig
	echo " * Compiling (using: $MAKEOPTS)"
	make $MAKEOPTS

	## Mount /boot if it exists
	if [[ ! -z $(grep /boot /etc/fstab) && -z $(mount | grep /boot) ]]; then
		echo " * Mounting /boot"
		mount /boot
		BOOT_MOUNTED=1
	fi
	echo " * Installing."
	make install modules_install
	mv /boot/System.map{,-${KERNEL_VER}}
	mv /boot/vmlinuz{,-${KERNEL_VER}}
	
	echo " * Generating grub config"
	grub-mkconfig -o /boot/grub/grub.cfg
	if [[ ! -z $BOOT_MOUNTED ]]; then
		echo " * Unmounting /boot"
		umount /boot
	fi
}

####
## Gather a list of packages based on what type of module we're needing to rebuild.
rebuildModules() {
	local type=$1
	case $type in
		kernel)
			type=KERNEL_MODULE ;;
		perl)
			type=PERL_MODULE ;;
		python)
			type=PYTHON_MODULE ;;
	esac
	for m in $(find ${PKG_CACHE} -iname $type | sed -e "s,/$type,," -e "s,${PKG_CACHE}/,,")
	do
		echo -n "$(getCategory $m)/$(getName $m) "
	done	
}

####
## Build Dependencies
## There are a few types of Dependencies
## 1) Run time (RDEPS)
## 2) Build time (BDEPS)
## 3) Binary (DEPS)
## 4) USE flag Dependencies (UDEPS)
## 5) Circular Dependencies (CDEPS)
##
## Because dependencies can change across versions, This
## will only update the BDEPS of the installed package.
buildBDeps() {
	local OUT=

	## Use our BDEPS file installed within PKG_CACHE
	PKG=$(Installed-getPkg $1 | sed 's,/[^/]*/$,,')

	[ $VERBOSE -ge 1 ] && echo -n "$PKG ( "

	## Filter out the Toolchain. These are always depended on,
	## So we don't need it complicating the logic
	PKG_FILTER=("sys-apps/util-linux" "sys-libs/glibc" "sys-devel/gcc")

	(
		source "$PKG_CACHE/$PKG/$(getVerRev $PKG).build"
		if pkg-restricts "nobin"; then
			[ $VERBOSE -ge 1 ] && echo " none )"
			return
		fi

		PKG_FILTER+=(${CDEPS[@]})
		## For this to work properly we need to save our USE flag and set it to this prior to sourcing
		## If the user changes it after its been installed, it may skew the results.
		PKG_FILTER+=(${UDEPS[@]})

		## Force a refresh of the BDEPS file.
		if [[ $FORCE == 1 ]]; then
			getBDeps "$PKG_CACHE/$PKG/CONTENTS"
		fi

		## Itterate over it and find matching files within each package's CONTENTS
		for dep in $(cat "$PKG_CACHE/$PKG/BDEPS"); do
			## readlink to resolve relative paths that occationally show up.
			## use dirname first in case the file is a symlink
			dep=$(readlink -f $(dirname $dep))/${dep##*/}

			## Grab a list of category/PKG names for each file.
			## It is possible for multiple results to occur.
			O=$(grep -r "$dep\$" $PKG_CACHE/*/*/*/CONTENTS |
				sed -e 's,:.*,,' \
				    -e "s,$PKG_CACHE/,," \
				    -e 's,/CONTENTS,,' \
					-e 's,\(.*/.*\)/.*,\1,')
			## No package found for the file.
			if [[ -z $O ]]; then
				>&2 echo " !! $dep Not found in any package"
				continue
			fi
			## Filter out itself.
			[[ "${PKG%/*}" == "$O" ]] && continue

			## If its not within our filter, or already added, add it to the list.
			if [[ ! ${PKG_FILTER[*]} =~ (^|[[:space:]]|=|>|<)"$O"($|[[:space:]]|:|-[0-9]) &&
				  ! $OUT =~ (^|[[:space:]])"$O"($|[[:space:]]) ]]; then
				OUT+=" $O"
				[ $VERBOSE -ge 1 ] && echo -n "$O '$d' "
			fi
		done

		[ $VERBOSE -ge 1 ] && echo ")"
		## Filter out duplicates we didn't catch earlier.
		D=$(echo $OUT|tr ' ' '\n'|sort|uniq|tr '\n' ' ')
		## Trim the space at the end for cosmetic reasoning.
		D=${D%% }
		## Dependencies
		grep '^DEPS=' $PKG_DB_DIR/$PKG.build > /dev/null 2>&1
		if [ $? != 0 ]; then
			echo -n "DEPS Missing - checking for BDEPS: "
			grep '^BDEPS=' $PKG_DB_DIR/$PKG.build > /dev/null 2>&1
			if [ $? == 0 ]; then
				echo "Updating."
				sed -i 's,^BDEPS=["'\'']\(.*\)\["'\''],DEPS=\"\1\"\nBDEPS=\"\",' $PKG_DB_DIR/$PKG.build
			else
				echo "Not found, Skipping.."
				continue
			fi
		fi
		
		## Theoretically speaking sorting is wasted if this is exclusively used
		## to add DEPS, but this isn't always the case.
		## sort things to avoid false-positives
		LD=$(grep '^DEPS=' $PKG_DB_DIR/$PKG.build | sed -e 's,^DEPS=["'\''],,' -e 's,["'\''].*,,'|tr ' ' '\n'|sort|uniq|tr '\n' ' ')

		## If any need updating
		if [[ ${LD%% } != $D ]]; then
			AD=
			for l in $D; do
				if [[ ! $LD =~ (^|[[:space:]])"$l"($|[[:space:]]) ]]; then
					AD+=" $l"
				fi
			done
			RD=
			for l in $LD; do
				if [[ ! $D =~ (^|[[:space:]])"$l"($|[[:space:]]) ]]; then
					RD+=" $l"
				fi
			done
		
			echo " * Updating $PKG:"
			[[ ! -z $AD ]] && echo "  - Added:$AD"
			[[ ! -z $RD ]] && echo "  - Removed:$RD"
			if [[ $PRETEND != 1 ]]; then
				sed -i "s,^DEPS=[\"'].*[\"'],DEPS=\"${D}\"," $PKG_DB_DIR/$PKG.build
			fi
		fi
	
	)
	HASH_UPDATE=true
}

## Fetch a file from a given address
## Optionally save it under a given name.
fetch_file() {
	## Just Ignore Empty calls.
	[[ $1 == "" ]] && return 0
	FILE=${1##*/}
	OUTFILE=$2

	## No custom outfile .. just save it as normal
	[[ $OUTFILE == "" ]] && OUTFILE=$FILE

	## If we already exist, ignore it
	[ -e "${DISTFILES}/${OUTFILE}" ] && return 0
	wget -c -O "${DISTFILES}/${OUTFILE}" "$1"

	## If we encounter an Error, delete the file and error out.
	if [ $? != 0 ]; then
		[[ -e "$DISTFILES/$OUTFILE" ]] && rm "${DISTFILES}/${OUTFILE}"
		echo "   FILE: $FILE"
		echo "OUTFILE: $OUTFILE"
		echo "1: $1"
		echo "2: $2"
		die "Error Downloading";
	fi
}

## Check a sha1sum of a given file within the package's sha1 file.
checkSha1() {
	[[ $IGNORE_SHA1 == 1 || $MODE == 'uninstall' ]] && return 0
	PKG=$1
	FILE=$2

	## Ignore Empty calls
	[[ $FILE == "" ]] && return 0

	[[ $VERBOSE -ge 2 ]] && >&2 echo -n "Checking Sha1: $FILE ... "
	[ ! -e $FILE ] && echo "Failed checking $PKG sha1" && return 1
	h=$(sha1sum $FILE | sed 's,  .*/,  ,' 2> /dev/null)
	[[ $VERBOSE -ge 2 ]] && >&2 echo -n $h
	grep "$h" $PKG/sha1 > /dev/null 2>&1
	if [[ $? == 0 ]]; then
		[[ $VERBOSE -ge 2 ]] && >&2 echo " ..Ok"
	else
		return 1
	fi
	return 0
}

preservedRebuild() {
	## Files were preserved, process them here to ensure we don't break our system.
	if [ -e /tmp/preserved ]; then
		echo " * Gathering list of packages to rebuild"
		REQUESTED_LIST=
		for f in $(cat /tmp/preserved); do
			echo -n "$f:"
			pkgs=$(checkFileDep $f | sort|uniq|tr '\n' ' ')
			echo " $pkgs"
			for d in $pkgs; do
				p=${d%/*}
				slot=$(grep 'SLOT=' "$PKG_CACHE/$d/${d##*/}.build" | sed 's,.*SLOT=,,')
				if [[ ! $REQUESTED_LIST =~ (^|[[:space:]])"$p"($|-|:|[[:space:]]) ]]; then
					REQUESTED_LIST+=" $p:$slot"
				fi
			done
		done
		list=
		getFullPkgList $REQUESTED_LIST
		for p in $(cat /tmp/chart); do
			setupENV $p

			if [[ $(version_gt $PKG_VR $O_VER) == 0 ||
				$REQUESTED_LIST =~ (^|[[:space:]])"$PKG_CAT/$PKG_NAME"($|[[:space:]]) ]]; then
				echo -n "$PKG_CAT/$PKG_NAME - $PKG_VR [ $O_VER ]"
				[[ $FORCE == 1 ]] && echo -n " (forced)"
				[[ ! -z $IUSE ]] && echo -n " [ $IUSE ]"
				echo
				list+=" $LENTRY"
			fi
		done
		[ $PRETEND == 1 ] && exit 0

		installList $list
		for f in $(cat /tmp/preserved); do
			rm "$f" 2> /dev/null && echo " << $f" || echo " <! $f"
		done
		rm /tmp/preserved
	fi
}
