####
## This requires a /usr/src/linux symlink to our kernel
## and either a .config within the directory OR /proc/config.gz to be enabled within our running kernel.
##
## Auto mounting of /boot is available
## vmlinuz and System.map will be renamed to match the kernel version.
## a grub config will also be automatically be generated.
buildKernel() {
	## Detect our config file
	[ ! -e /usr/src/linux ] && die "you should set your /usr/src/linux symlink to a valid kernel source."
	if [[ ! -e /usr/src/linux/.config && ! -e /proc/config.gz ]]; then
		echo "Cannot Build kernel without either a /proc/config.gz or a /usr/src/linux/.config"
		die "Please go to /usr/src/linux and run: make menuconfig"
	fi
	if [[ -e /proc/config.gz && ! -e /usr/src/linux/.config ]]; then
		gzip -cd /proc/config.gz > /usr/src/linux/.config
		echo " * Using current running kernel's config"
	fi

	## Get our kernel version from the symlink.
	KERNEL_VER=$(readlink /usr/src/linux | sed -e 's,.*linux-,,' -e 's,/$,,')
	echo " * Building Kernel - $KERNEL_VER"
	
	cd /usr/src/linux

	####
	## Set some default config values here

	## Set the default init to OpenRC.
	#sed -i '/CONFIG_DEFAULT_INIT/ s,"","/sbin/openrc-init",' .config

	echo " * Running: make oldconfig"
	make oldconfig
	echo " * Compiling (using: $MAKEOPTS)"
	make $MAKEOPTS

	## Mount /boot if it exists
	if [[ ! -z $(grep /boot /etc/fstab) && -z $(mount | grep /boot) ]]; then
		echo " * Mounting /boot"
		mount /boot
		BOOT_MOUNTED=1
	fi
	echo " * Installing."
	make install modules_install
	mv /boot/System.map{,-${KERNEL_VER}}
	mv /boot/vmlinuz{,-${KERNEL_VER}}
	
	echo " * Generating grub config"
	grub-mkconfig -o /boot/grub/grub.cfg
	if [[ ! -z $BOOT_MOUNTED ]]; then
		echo " * Unmounting /boot"
		umount /boot
	fi
}

####
## Gather a list of packages based on what type of module we're needing to rebuild.
rebuildModules() {
	local type=$1
	case $type in
		kernel)
			type=KERNEL_MODULE ;;
		perl)
			type=PERL_MODULE ;;
		python)
			type=PYTHON_MODULE ;;
	esac
	for m in $(find ${PKG_CACHE} -iname $type | sed -e "s,/$type,," -e "s,${PKG_CACHE}/,,")
	do
		echo -n "$(getCategory $m)/$(getName $m) "
	done	
}

####
## Build Dependencies
## There are a few types of Dependencies
## 1) Run time (RDEPS)
## 2) Build time (BDEPS)
## 3) Binary (DEPS)
## 4) USE flag Dependencies (UDEPS)
## 5) Circular Dependencies (CDEPS)
##
## Because dependencies can change across versions, This
## will only update the BDEPS of the installed package.
buildBDeps() {
	local OUT=
	## Use our BDEPS file installed within PKG_CACHE
	PKG=$(Installed-getPkg $1 | sed 's,/[^/]*/$,,')
	## Filter out the Toolchain. These are always depended on,
	## So we don't need it complicating the logic
	PKG_FILTER=("sys-apps/util-linux" "sys-libs/glibc" "sys-devel/gcc")

	(
		source "$PKG_CACHE/$PKG/$(getVerRev $PKG).build"
		PKG_FILTER+=(${CDEPS[@]})
		## For this to work properly we need to save our USE flag and set it to this prior to sourcing
		## If the user changes it after its been installed, it may skew the results.
		PKG_FILTER+=(${UDEPS[@]})

		## Force a refresh of the BDEPS file.
		if [[ $FORCE == 1 ]]; then
			getBDeps "$PKG_CACHE/$PKG/CONTENTS"
		fi

		[ $VERBOSE -ge 1 ] && echo -n "$PKG ( "
		## Itterate over it and find matching files within each package's CONTENTS
		for dep in $(cat "$PKG_CACHE/$PKG/BDEPS"); do
			## readlink to resolve relative paths that occationally show up.
			## use dirname first in case the file is a symlink
			dep=$(readlink -f $(dirname $dep))/${dep##*/}

			## Grab a list of category/PKG names for each file.
			## It is possible for multiple results to occur.
			O=$(grep -r "$dep\$" $PKG_CACHE/*/*/*/CONTENTS |
				sed -e 's,:.*,,' \
				    -e "s,$PKG_CACHE/,," \
				    -e 's,/CONTENTS,,' \
					-e 's,\(.*/.*\)/.*,\1,')
			## No package found for the file.
			if [[ -z $O ]]; then
				>&2 echo " !! $dep Not found in any package"
				continue
			fi
			## Filter out itself.
			[[ "${PKG%/*}" == "$O" ]] && continue

			## If its not within our filter, or already added, add it to the list.
			if [[ ! ${PKG_FILTER[*]} =~ (^|[[:space:]])"$O"($|[[:space:]]) && 
				  ! $OUT =~ (^|[[:space:]])"$O"($|[[:space:]]) ]]; then
				OUT+=" $O"
				[ $VERBOSE -ge 1 ] && echo -n "$O '$d' "
			fi
		done

		[ $VERBOSE -ge 1 ] && echo ")"
		## Filter out duplicates we didn't catch earlier.
		D=$(echo $OUT|tr ' ' '\n'|sort|uniq|tr '\n' ' ')
		## Trim the space at the end for cosmetic reasoning.
		D=${D%% }
		## Dependencies
		grep '^DEPS=' $PKG_DB_DIR/$PKG.build > /dev/null 2>&1
		if [ $? != 0 ]; then
			echo -n "DEPS Missing - checking for BDEPS: "
			grep '^BDEPS=' $PKG_DB_DIR/$PKG.build > /dev/null 2>&1
			if [ $? == 0 ]; then
				echo "Updating."
				sed -i 's,^BDEPS=["'\'']\(.*\)\["'\''],DEPS=\"\1\"\nBDEPS=\"\",' $PKG_DB_DIR/$PKG.build
			else
				echo "Not found, Skipping.."
				continue
			fi
		fi
		
		## Theoretically speaking sorting is wasted if this is exclusively used
		## to add DEPS, but this isn't always the case.
		## sort things to avoid false-positives
		LD=$(grep '^DEPS=' $PKG_DB_DIR/$PKG.build | sed -e 's,^DEPS=["'\''],,' -e 's,["'\''].*,,'|tr ' ' '\n'|sort|uniq|tr '\n' ' ')

		## If any need updating
		if [[ ${LD%% } != $D ]]; then
			AD=
			for l in $D; do
				if [[ ! $LD =~ (^|[[:space:]])"$l"($|[[:space:]]) ]]; then
					AD+=" $l"
				fi
			done
			RD=
			for l in $LD; do
				if [[ ! $D =~ (^|[[:space:]])"$l"($|[[:space:]]) ]]; then
					RD+=" $l"
				fi
			done
		
			echo " * Updating $PKG:"
			[[ ! -z $AD ]] && echo " - Added:$AD"
			[[ ! -z $RD ]] && echo " - Removed:$RD"
			sed -i "s,^DEPS=[\"'].*[\"'],DEPS=\"${D}\"," $PKG_DB_DIR/$PKG.build
		fi
	
	)
	HASH_UPDATE=true
}
